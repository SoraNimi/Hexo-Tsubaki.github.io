<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nimisora.com/"/>
  <updated>2020-03-14T14:31:20.272Z</updated>
  <id>http://nimisora.com/</id>
  
  <author>
    <name>SoraNimi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <link href="http://nimisora.com/post/3ZYPPMZ.html"/>
    <id>http://nimisora.com/post/3ZYPPMZ.html</id>
    <published>2020-03-14T14:14:40.000Z</published>
    <updated>2020-03-14T14:31:20.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; cur=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,target,cur,res);</span><br><span class="line">        <span class="comment">//因为需要返回的数组中数组长度大的在前面，所以使用Collecions.sore,结合lamda表达</span></span><br><span class="line">        <span class="comment">//式进行排序</span></span><br><span class="line">        Collections.sort(res,<span class="keyword">new</span> Comparator&lt;ArrayList&lt;Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ArrayList&lt;Integer&gt;o1,ArrayList&lt;Integer&gt;o2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.size()&lt;o2.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt;cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value=root.val;</span><br><span class="line">        cur.add(value);</span><br><span class="line">        <span class="keyword">if</span>(target==value&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//注意，在这里需要add函数中new一个实例，不然最后传入的是空数组</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            helper(root.left,target-value,cur,res);</span><br><span class="line">            helper(root.right,target-value,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树中和为某一值的路径&quot;&gt;&lt;a href=&quot;#二叉树中和为某一值的路径&quot; class=&quot;headerlink&quot; title=&quot;二叉树中和为某一值的路径&quot;&gt;&lt;/a&gt;二叉树中和为某一值的路径&lt;/h3&gt;&lt;p&gt;输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://nimisora.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>23.合并K个排序链表</title>
    <link href="http://nimisora.com/post/3Y651F0.html"/>
    <id>http://nimisora.com/post/3Y651F0.html</id>
    <published>2020-03-13T08:50:01.000Z</published>
    <updated>2020-03-13T08:55:54.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h3><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode **ppcur = &amp;head;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">list</span> : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>)</span><br><span class="line">                pq.emplace(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = pq.top(); pq.pop();</span><br><span class="line">            *ppcur = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next) &#123;</span><br><span class="line">                pq.emplace(cur-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            ppcur = &amp;(*ppcur)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;合并K个排序链表&quot;&gt;&lt;a href=&quot;#合并K个排序链表&quot; class=&quot;headerlink&quot; title=&quot;合并K个排序链表&quot;&gt;&lt;/a&gt;合并K个排序链表&lt;/h3&gt;&lt;p&gt;合并 &lt;em&gt;k&lt;/em&gt; 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://nimisora.com/categories/Leetcode/"/>
    
    
      <category term="优先队列" scheme="http://nimisora.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java创建线程的四种方式</title>
    <link href="http://nimisora.com/post/3A03G67.html"/>
    <id>http://nimisora.com/post/3A03G67.html</id>
    <published>2020-03-12T07:54:48.000Z</published>
    <updated>2020-03-13T01:17:30.655Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>1、启动线程方式： 要启动的可以分为两类：返回结果和不返回结果。对于这两种，也分别有两种启动线程的方式：</p><p>1）继承Thread类，implements Runnable接口</p><p>2）实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的线程</p><h3 id="第一种：继承Thread类创建方程"><a href="#第一种：继承Thread类创建方程" class="headerlink" title="第一种：继承Thread类创建方程"></a>第一种：继承Thread类创建方程</h3><p>Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(Thread.currentThread().getName()+<span class="string">"is running!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread myThread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread1.start();</span><br><span class="line">        myThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-0is running!</span><br><span class="line">Thread-1is running!</span><br></pre></td></tr></table></figure><hr><p><strong>2、实现Runnable接口创建线程</strong></p><p>如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName()+<span class="string">" is Running!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread1=<span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread myThread2=<span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread1=<span class="keyword">new</span> Thread(myThread1);</span><br><span class="line">        Thread thread2=<span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-1is running!</span><br><span class="line">Thread-0is running!</span><br></pre></td></tr></table></figure><p>在传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，参考JDK源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">　　<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;  </span><br><span class="line">　　 target.run();  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>3、实现Callable接口通过FutureTask包装器来创建Thread线程</p><p>和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法功能要强大。</p><ul><li>call()方法可以有返回值</li><li>call()方法可以声明抛出异常</li></ul><p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p><blockquote><p>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p></blockquote><blockquote><p>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p></blockquote><blockquote><p>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p></blockquote><blockquote><p>boolean isDone()：若Callable任务完成，返回True</p></blockquote><blockquote><p>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p></blockquote><p>介绍了相关的概念之后，创建并启动有返回值的线程的步骤如下：</p><p>1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p><p>2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p><p>3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p><p>4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CallableDemo callable=<span class="keyword">new</span> CallableDemo();</span><br><span class="line">        FutureTask&lt;Integer&gt;futureTask=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        Integer result=futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>1、FutrueTask类实现了RunnableFutrue接口，如下图</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcqvqhhjm0j30jr01yaa2.jpg" alt="http://www.studyshare.cn/upload/images/201904242207460286193.png"></p><p>2、RunnableFutrue接口继承了Runnable和Futrue接口，如下图</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcqvqgwapyj30ks06h74q.jpg" alt="http://www.studyshare.cn/upload/images/201904242209144468129.png"></p><p>由上图即可发现，FutrueTask类间接的实现了Runnable接口，从而可以使用new Thread(new FutrueTask(callable))去调用线程的start()方法启动线程。</p><p>3、继续进入Future接口中会发现get()方法</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcqvqggrp1j30o306gwf8.jpg" alt="http://www.studyshare.cn/upload/images/201904242212373121310.png"></p><p>因此FutrueTask可以通过调用get()方法获取到返回的结果。用一张图来总结以上几个类和接口之间的关系，如下图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcqvqif8t0j30k50gd0u0.jpg" alt="http://www.studyshare.cn/upload/images/201904242214137117738.png"></p><hr><h3 id="4、使用ExecutorService、Callable、Future实现有返回结果的线程"><a href="#4、使用ExecutorService、Callable、Future实现有返回结果的线程" class="headerlink" title="4、使用ExecutorService、Callable、Future实现有返回结果的线程"></a>4、使用ExecutorService、Callable、Future实现有返回结果的线程</h3><p>ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，有了这种特征就不需要再为了得到返回值而大费周折了。而且自己实现了也可能漏洞百出。</p><p>可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。</p><p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。</p><p>注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。</p><p>再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。</p><p>下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下：</p><p>Test类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有返回值的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,</span></span><br><span class="line"><span class="function">            InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----程序开始运行----"</span>);</span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> taskSize = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">        <span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">        List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">            Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 执行任务并获取Future对象</span></span><br><span class="line">            Future f = pool.submit(c);</span><br><span class="line">            <span class="comment">// System.out.println("&gt;&gt;&gt;" + f.get().toString());</span></span><br><span class="line">            list.add(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line">        <span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">            <span class="comment">// 从Future对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + f.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"----程序结束运行----，程序运行时间【"</span></span><br><span class="line">                + (date2.getTime() - date1.getTime()) + <span class="string">"毫秒】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyCallable类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String taskNum;</span><br><span class="line"></span><br><span class="line">    MyCallable(String taskNum) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskNum = taskNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务启动"</span>);</span><br><span class="line">        Date dateTmp1 = <span class="keyword">new</span> Date();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Date dateTmp2 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> time = dateTmp2.getTime() - dateTmp1.getTime();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务终止"</span>);</span><br><span class="line">        <span class="keyword">return</span> taskNum + <span class="string">"任务返回运行结果,当前任务时间【"</span> + time + <span class="string">"毫秒】"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：上述代码中Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。public static ExecutorService newFixedThreadPool(int nThreads) 创建固定数目线程的线程池。public static ExecutorService newCachedThreadPool() 创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的Executor。public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。</p><p><a href="https://www.cnblogs.com/darendu/p/10778671.html" target="_blank" rel="noopener">线程之Callable、Future 和FutureTask使用及源码分析</a></p><p><a href="https://www.cnblogs.com/hplsharenote/p/9822486.html" target="_blank" rel="noopener">java创建线程的四种方法（转） - 小白和熊猫 - 博客园</a></p><p><a href="https://www.cnblogs.com/felixzh/p/6036074.html" target="_blank" rel="noopener">JAVA多线程实现的四种方式</a></p><p>具体使用请参考：<a href="https://www.cnblogs.com/felixzh/p/6036074.html但是这里对FutureTask结果返回没有说明，参考下篇" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/6036074.html但是这里对FutureTask结果返回没有说明，参考下篇</a></p><p>2、线程池的种类 四种。</p><p>查了网上的一些资料，上面都是先讲线程池存在的必要性：针对一些需要处理的短小而数量巨多的线程。比如在服务器中客户端浏览器的请求就有短小数量多的特点。</p><p>如果我们单纯地执行来一个请求回复一个，来回切换线程的代价太大。比如你要二十种不同的水果，他们分别放在相隔一米的管道里，并且每种水果发来的请求不一致，比如有的想要去皮，有的想要切盘，这时线程可以看作是“去皮”“切盘”前的准备工作，比如冲洗一下或者准备水果刀之类的。把线程准备好之后就可以进行最后的处理。</p><p>这时候，如果苹果说他想去皮，你要准备水果刀，再传过去给老大处理，二十米开外的菠萝说他想切块，你得准备螺丝刀，再给老大处理，是不是很麻烦，来回跑下来累得不行，还要准备不同的工具，效率太低。这时候就有了线程池的说法。线程池，每一个线程为一个要求服务，比如去皮，就创建去皮的线程，去核，就创建去核的线程（一般来说，某种水果对应的要求是一致的）。这里线程就是为去核，去皮做准备工作。这时候，就不用重复准备工作了。</p><p>四种线程池：<a href="https://www.cnblogs.com/aaron911/p/6213808.html" target="_blank" rel="noopener">https://www.cnblogs.com/aaron911/p/6213808.html</a></p><pre><code>https://blog.csdn.net/z_s_z2016/article/details/81674893?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></pre><p> ———————————————— 版权声明：本文为CSDN博主「murongxian_1」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：<a href="https://blog.csdn.net/murongxian_1/article/details/81109294" target="_blank" rel="noopener">https://blog.csdn.net/murongxian_1/article/details/81109294</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、启动线程方式： 要启动的可以分为两类：返回结果和不返回结果。对于这两种，也分别有两种启动线程的方式：&lt;/p&gt;
&lt;p&gt;1）继承Thread类，implements Runnable接口&lt;/p&gt;
&lt;p&gt;2）实现Callable接口通过FutureTask包
      
    
    </summary>
    
    
      <category term="Java" scheme="http://nimisora.com/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://nimisora.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized底层实现原理</title>
    <link href="http://nimisora.com/post/305BPMG.html"/>
    <id>http://nimisora.com/post/305BPMG.html</id>
    <published>2020-03-07T02:42:10.000Z</published>
    <updated>2020-03-13T08:43:58.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="synchronized的底层实现原理及各种优化"><a href="#synchronized的底层实现原理及各种优化" class="headerlink" title="synchronized的底层实现原理及各种优化"></a>synchronized的底层实现原理及各种优化</h3><p>synchronized概述<br>synchronized，单词译为同步，是Java的内建锁，用来确保线程安全，是解决并发问题的一种重要手段。synchronized可以保证在多线程状态下，每次仅有一个线程访问共享资源。</p><p>synchronized的作用主要有以下三个：</p><p><strong>原子性：线程互斥的访问同步代码块，可以将小原子合成大原子。</strong><br><strong>可见性：synchronized解锁之前，必须将工作内存中的数据同步到主内存，其它线程操作该变量时每次都可以看到被修改后的值。</strong><br><strong>有序性：一个线程的加锁，必须等到其它线程将锁释放；一个线程要释放锁，首先要加锁。</strong><br><strong>synchronized同步原理</strong><br>synchronized仅是Java中的一个关键字，在使用的过程中并没有看到显示的加锁和解锁过程。因此有必要通过javap命令，查看相应的字节码文件。</p><p><strong>synchronized修饰代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap查看相应的class文件：</p><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/image23.png" alt="image-20200307102543060"></p><p>可以看出在执行同步代码块之前之后都有一个monitor字样，其中前面的是monitorenter，后面的是离开monitorexit，不难想象一个线程也执行同步代码块，首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。</p><p>为什么会有两个monitorexit呢？</p><p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</p><p>synchronized修饰方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello again"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/20190430231557677.png" alt="在这里插入图片描述"></p><p><strong>仅有ACC_SYNCHRONIZED这么一个标志，该标记表明线程进入该方法时，需要monitorenter，退出该方法时需要monitorexit。</strong></p><p>synchronized可重入的原理<br><strong>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。</strong>底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><p>锁优化<br>JDK1.6之前，synchronized是一个重量级锁，何谓重量级锁？就是多个线程竞争同一把锁，未获得锁的线程都会被阻塞，等到持有锁的线程将锁释放之后，这些线程又被唤醒。其中线程的阻塞和唤醒都与操作系统有关，是一个极其耗费CPU资源的过程。因此为了提高synchronized的性能特地在JDK1.6做了优化。据说在JDK1.4已经优化完成，不过默认是关闭状态。</p><p>在了解锁优化之前需要先了解一些概念：<br>Java对象内存模型</p><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/2019043023230896-20200307102749191.png" alt="在这里插入图片描述"></p><p><strong>一个Java对象由，对象标记，类型指针，真实数据，内存对齐四部分组成。</strong></p><p>对象标记也称Mark Word字段，存储当前对象的一些运行时数据。<br>类型指针，JVM根据该指针确定该对象是哪个类的实例化对象。<br>真实数据自然是对象的属性值。<br>内存补齐，是当数据不是对齐数的整数倍的时候，进行调整，使得对象的整体大小是对齐数的整数倍方便寻址。典型的以空间换时间的思想。<br>其中对象标记和类型指针统称为Java对象头。</p><p><strong>Mark Word字段</strong><br>Mark Word用于存储对象自身运行时的数据，如hashcode，GC分代年龄，锁状态标志位，线程持有的锁，偏向线程ID，等等。</p><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/asdf.jpg" alt="在这里插入图片描述"></p><p>为社么Java的任意对象都可以作为锁？<br>在Java对象头中，存在一个monitor对象，每个对象自创建之后在对象头中就含有monitor对象，monitor是线程私有的，不同的对象monitor自然也是不同的，因此对象作为锁的本质是对象头中的monitor对象作为了锁。这便是为什么Java的任意对象都可以作为锁的原因。</p><p>优化手段<br>偏向锁：<br>偏向锁针对的是锁不存在竞争，每次仅有一个线程来获取该锁，为了提高获取锁的效率，因此将该锁偏向该线程。提升性能。</p><p>偏向锁的获取：</p><p><strong>1.首先检测是否为可偏向状态（锁标识是否设置成1，锁标志位是否为01）.</strong><br><strong>2.如果处于可偏向状态，测试Mark Word中的线程ID是否指向自己，如果是，不需要再次获取锁，直接执行同步代码。</strong><br><strong>3.如果线程Id，不是自己的线程Id，通过CAS获取锁，获取成功表明当前偏向锁不存在竞争，获取失败，则说明当前偏向锁存在锁竞争，偏向锁膨胀为轻量级锁。</strong></p><p>偏向锁的撤销：</p><p>偏向锁只有当出现竞争时，才会出现锁撤销。</p><p><strong>1。等待一个全局安全点，此时所有的线程都是暂停的，检查持有锁的线程状态，如果能找到说明当前线程还存活，说明还在执行同步块中的代码，首相将该线程阻塞，然后进行锁升级，升级到轻量级锁，唤醒该线程继续执行代同步码。</strong><br><strong>2.如果持有偏向锁的线程未存活，将对象头中的线程置null，然后直接锁升级。</strong></p><p>轻量级锁：<br>偏向锁考虑的是不存在多个线程竞争同一把锁，而轻量级锁考虑的是，多个线程不会在同一时刻来竞争同一把锁。</p><p>轻量级锁的获取：</p><p><strong>1.在线程的栈帧中创建用于存储锁记录得空间，</strong><br><strong>2.并将Mark Word复制到锁记录中，（这一步不论是否存在竞争都可以执行）。</strong><br><strong>3.尝试使用CAS将对象头中得Mark word字段变成指向锁记录得指针。</strong><br><strong>4 操作成功，不存在锁竞争，执行同步代码。</strong><br><strong>5操作失败，锁已经被其它线程抢占了，这时轻量级锁膨胀为重量级锁。</strong></p><p><strong>轻量级锁的释放：</strong></p><p>反替换，使用CAS将栈帧中得锁录空间替换到对象头，成功没有锁竞争，锁得以释放，失败说明存在竞争，那块指向锁记录得指针有别的线程在用，因此锁膨胀升级为重量级锁。</p><p><strong>重量级锁：</strong><br>重量级锁描述同一时刻有多个线程竞争同一把锁。</p><p>当多个线程共同竞争同一把锁时，竞争失败得锁会被阻塞，等到持有锁的线程将锁释放后再次唤醒阻塞的线程，因为线程的唤醒和阻塞是一个很耗费CPU资源的操作，因此此处采取自适应自旋来获取重量级锁来获取重量级锁。</p><p><strong>锁的升级</strong><br>无锁 – &gt; 偏向锁 —–&gt; 轻量级锁 —- &gt; 重量级锁</p><p>其它优化<br><strong>自旋锁</strong>：<br>线程未获得锁后，不是一昧的阻塞，而是让线程不断尝试获取锁。</p><p>缺点：若线程占用锁时间过长，导致CPU资源白白浪费。</p><p>解决方式：当尝试次数达到每个值得时候，线程挂起。</p><p><strong>自适应自旋锁：</strong><br>自旋得次数由上一次获取锁的自旋次数决定，次数稍微延长一点点。</p><p><strong>锁消除</strong><br>对于线程的私有变量，不存在并发问题，没有必要加锁，即使加锁编译后，也会去掉。</p><p><strong>锁粗化</strong><br>当一个循环中存在加锁操作时，可以将加锁操作提到循环外面执行，一次加锁代替多次加锁，提升性能。<br>————————————————<br>版权声明：本文为CSDN博主「你的酒窝里有酒」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43213517/article/details/89713899" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43213517/article/details/89713899</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;synchronized的底层实现原理及各种优化&quot;&gt;&lt;a href=&quot;#synchronized的底层实现原理及各种优化&quot; class=&quot;headerlink&quot; title=&quot;synchronized的底层实现原理及各种优化&quot;&gt;&lt;/a&gt;synchronized的底
      
    
    </summary>
    
    
      <category term="Java" scheme="http://nimisora.com/categories/Java/"/>
    
    
      <category term="Synchronized" scheme="http://nimisora.com/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Collections知识点整理</title>
    <link href="http://nimisora.com/post/1GGZHEY.html"/>
    <id>http://nimisora.com/post/1GGZHEY.html</id>
    <published>2020-03-05T08:12:10.000Z</published>
    <updated>2020-03-13T08:55:19.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h3><ol><li><p><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>底层数据结构</strong>： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p></li><li><p><strong>插入和删除是否受元素位置的影响</strong>： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</p></li><li><p><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p></li><li><p><strong>内存空间占用</strong>： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ol><p>补充内容:RandomAccess接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Arraylist-与-LinkedList-区别&quot;&gt;&lt;a href=&quot;#Arraylist-与-LinkedList-区别&quot; class=&quot;headerlink&quot; title=&quot;Arraylist 与 LinkedList 区别?&quot;&gt;&lt;/a&gt;Arraylist 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://nimisora.com/categories/Java/"/>
    
    
      <category term="Collections" scheme="http://nimisora.com/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Volatile关键字及其实现原理</title>
    <link href="http://nimisora.com/post/1XVQCVA.html"/>
    <id>http://nimisora.com/post/1XVQCVA.html</id>
    <published>2020-03-05T02:13:29.000Z</published>
    <updated>2020-03-13T08:44:13.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="volatile的用法"><a href="#volatile的用法" class="headerlink" title="volatile的用法"></a>volatile的用法</h3><p>转载自：<a href="https://blog.csdn.net/zezezuiaiya/article/details/81456060" target="_blank" rel="noopener">https://blog.csdn.net/zezezuiaiya/article/details/81456060</a></p><p>volatile通常被比喻成”轻量级的synchronized”，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p><p>volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</p><p>如以下代码，是一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰可能被多个线程同时访问到的singleton。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h3><p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p><p>但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</p><p>缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><p>所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p><h3 id="volatile与可见性"><a href="#volatile与可见性" class="headerlink" title="volatile与可见性"></a>volatile与可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。</p><p>前面的关于volatile的原理中介绍过了，Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><h3 id="volatile与有序性"><a href="#volatile与有序性" class="headerlink" title="volatile与有序性"></a>volatile与有序性</h3><p>有序性即程序执行的顺序按照代码的先后顺序执行。</p><p>除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p><p>而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。</p><p>普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。</p><p>volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-&gt;add-&gt;save 的执行顺序就是：load、add、save。</p><h3 id="volatile与原子性"><a href="#volatile与原子性" class="headerlink" title="volatile与原子性"></a>volatile与原子性</h3><h3 id="原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。"><a href="#原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。" class="headerlink" title="原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。"></a>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</h3><p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</p><p>为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。</p><p>所以，volatile是不能保证原子性的。</p><p>在以下两个场景中可以使用volatile来代替synchronized：</p><p>1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。</p><p>2、变量不需要与其他状态变量共同参与不变约束。</p><p>除以上场景外，都需要使用其他方式来保证原子性，如synchronized或者concurrent包。</p><p>我们来看一下volatile和原子性的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较简单，就是创建10个线程，然后分别执行1000次i++操作。正常情况下，程序的输出结果应该是10000，但是，多次执行的结果都小于10000。这其实就是volatile无法满足原子性的原因。</p><p>为什么会出现这种情况呢，那就是因为虽然volatile可以保证inc在多个线程之间的可见性。但是无法inc++的原子性。</p><p>总结与思考<br>我们介绍过了volatile关键字和synchronized关键字。现在我们知道，synchronized可以保证原子性、有序性和可见性。而volatile却只能保证有序性和可见性。</p><p>-————————————————————————————————————————-</p><p><strong>前言</strong></p><p>我们知道volatile关键字的作用是保证变量在多线程之间的可见性，它是java.util.concurrent包的核心，没有volatile就没有这么多的并发类给我们使用。</p><p>本文详细解读一下volatile关键字如何保证变量在多线程之间的可见性，在此之前，有必要讲解一下CPU缓存的相关知识，掌握这部分知识一定会让我们更好地理解volatile的原理，从而更好、更正确地地使用volatile关键字。</p><p><strong>CPU缓存</strong></p><p><strong>CPU缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾</strong>，因为CPU运算速度要比内存读写速度快得多，举个例子：</p><ul><li>一次主内存的访问通常在几十到几百个时钟周期</li><li>一次L1高速缓存的读写只需要1~2个时钟周期</li><li>一次L2高速缓存的读写也只需要数十个时钟周期</li></ul><p>这种访问速度的显著差异，导致CPU可能会花费很长时间等待数据到来或把数据写入内存。</p><p>基于此，现在CPU大多数情况下读写都不会直接访问内存（CPU都没有连接到内存的管脚），取而代之的是CPU缓存，CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。</p><p>按照读取顺序与CPU结合的紧密程度，CPU缓存可分为：</p><ul><li>一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存</li><li>二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半</li><li>三级缓存：简称L3 Cache，部分高端CPU才有</li></ul><p>每一级缓存中所存储的数据全部都是下一级缓存中的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也相对递增。</p><p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有再从二级缓存中查找，如果还是没有再从三级缓存中或内存中查找。一般来说每级缓存的命中率大概都有80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。</p><p><strong>使用CPU缓存带来的问题</strong></p><p>用一张图表示一下CPU–&gt;CPU缓存–&gt;主内存数据读取之间的关系：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxquqxcj309q06x3yh.jpg" alt="img"></p><p>当系统运行时，CPU执行计算的过程如下：</p><ol><li>程序以及数据被加载到主内存</li><li>指令和数据被加载到CPU缓存</li><li>CPU执行指令，把结果写到高速缓存</li><li>高速缓存中的数据写回主内存</li></ol><p>如果服务器是单核CPU，那么这些步骤不会有任何的问题，但是如果服务器是多核CPU，那么问题来了，以Intel Core i7处理器的高速缓存概念模型为例（图片摘自《深入理解计算机系统》）：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxmqg8ej30fd0eo0z1.jpg" alt="img"></p><p>试想下面一种情况：</p><ol><li>核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存</li><li>核3做了上面同样的工作，这样核0与核3的缓存拥有同样的数据</li><li>核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存</li><li>核3访问该字节，由于核0并未将数据写回主存，数据不同步</li></ol><p>为了解决这个问题，CPU制造商制定了一个规则：<strong>当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效</strong>。于是，在上面的情况下，核3发现自己的缓存中数据已无效，核0将立即把自己的数据写回主存，然后核3重新读取该数据。</p><p><strong>反汇编Java字节码，查看汇编层面对volatile关键字做了什么</strong></p><p>有了上面的理论基础，我们可以研究volatile关键字到底是如何实现的。首先写一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2  * <span class="doctag">@author</span> 五月的仓颉http://www.cnblogs.com/xrq730/p/7048693.html</span></span><br><span class="line"><span class="comment"> 3  */</span></span><br><span class="line"> <span class="number">4</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">7</span>     </span><br><span class="line"> <span class="number">8</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">10</span>             instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"><span class="number">11</span>         &#125;</span><br><span class="line"><span class="number">12</span>         </span><br><span class="line"><span class="number">13</span>         <span class="keyword">return</span> instance;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     </span><br><span class="line"><span class="number">16</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">17</span>         LazySingleton.getInstance();</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     </span><br><span class="line"><span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure><p>首先反编译一下这段代码的.class文件，看一下生成的字节码：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxmt6u4j30m808h75y.jpg" alt="img"></p><p>没有任何特别的。要知道，字节码指令，比如上图的getstatic、ifnonnull、new等，最终对应到操作系统的层面，都是转换为一条一条指令去执行，我们使用的PC机、应用服务器的CPU架构通常都是IA-32架构的，这种架构采用的指令集是CISC（复杂指令集），而汇编语言则是这种指令集的助记符。</p><p>因此，既然在字节码层面我们看不出什么端倪，那下面就看看将代码转换为汇编指令能看出什么端倪。Windows上要看到以上代码对应的汇编码不难（吐槽一句，说说不难，为了这个问题我找遍了各种资料，差点就准备安装虚拟机，在Linux系统上搞了），访问<a href="https://sourceforge.net/projects/fcml/files/fcml-1.1.1/hsdis-1.1.1-win32-amd64.zip/download" target="_blank" rel="noopener">hsdis工具路径</a>可直接下载hsdis工具，下载完毕之后解压，将hsdis-amd64.dll与hsdis-amd64.lib两个文件放在%JAVA_HOME%\jre\bin\server路径下即可，如下图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxo2bryj30v809d0yx.jpg" alt="img"></p><p>然后跑main函数，跑main函数之前，加入如下虚拟机参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*LazySingleton.getInstance</span><br></pre></td></tr></table></figure><p>运行main函数即可，代码生成的汇编指令为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span> <span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: PrintAssembly is enabled</span>; turning on DebugNonSafepoints to gain additional output</span><br><span class="line"> <span class="number">2</span> CompilerOracle: compileonly *LazySingleton.getInstance</span><br><span class="line"> <span class="number">3</span> Loaded disassembler from D:\JDK\jre\bin\server\hsdis-amd64.dll</span><br><span class="line"> <span class="number">4</span> Decoding compiled method <span class="number">0x0000000002931150</span>:</span><br><span class="line"> <span class="number">5</span> Code:</span><br><span class="line"> <span class="number">6</span> Argument <span class="number">0</span> is unknown.RIP: <span class="number">0x29312a0</span> Code size: <span class="number">0x00000108</span></span><br><span class="line"> <span class="number">7</span> [Disassembling <span class="keyword">for</span> mach=<span class="string">'amd64'</span>]</span><br><span class="line"> <span class="number">8</span> [Entry Point]</span><br><span class="line"> <span class="number">9</span> [Verified Entry Point]</span><br><span class="line"><span class="number">10</span> [Constants]</span><br><span class="line">11   # &#123;method&#125; 'getInstance' '()Lorg/xrq/test/design/singleton/LazySingleton;' in 'org/xrq/test/design/singleton/LazySingleton'</span><br><span class="line">12   #           [sp+0x20]  (sp of caller)</span><br><span class="line"><span class="number">13</span>   <span class="number">0x00000000029312a0</span>: mov     dword ptr [rsp+<span class="number">0f</span>fffffffffffa000h],eax</span><br><span class="line"><span class="number">14</span>   <span class="number">0x00000000029312a7</span>: push    rbp</span><br><span class="line"><span class="number">15</span>   <span class="number">0x00000000029312a8</span>: sub     rsp,<span class="number">10</span>h           ;*synchronization entry</span><br><span class="line"><span class="number">16</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@-<span class="number">1</span> (line <span class="number">13</span>)</span><br><span class="line"><span class="number">17</span>   <span class="number">0x00000000029312ac</span>: mov     r10,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">18</span>   <span class="number">0x00000000029312b6</span>: mov     r11d,dword ptr [r10+<span class="number">58</span>h]</span><br><span class="line"><span class="number">19</span>                                                 ;*getstatic instance</span><br><span class="line"><span class="number">20</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">0</span> (line <span class="number">13</span>)</span><br><span class="line"><span class="number">21</span>   <span class="number">0x00000000029312ba</span>: test    r11d,r11d</span><br><span class="line"><span class="number">22</span>   <span class="number">0x00000000029312bd</span>: je      <span class="number">29312e0</span>h</span><br><span class="line"><span class="number">23</span>   <span class="number">0x00000000029312bf</span>: mov     r10,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">24</span>   <span class="number">0x00000000029312c9</span>: mov     r11d,dword ptr [r10+<span class="number">58</span>h]</span><br><span class="line"><span class="number">25</span>   <span class="number">0x00000000029312cd</span>: mov     rax,r11</span><br><span class="line"><span class="number">26</span>   <span class="number">0x00000000029312d0</span>: shl     rax,<span class="number">3</span>h            ;*getstatic instance</span><br><span class="line"><span class="number">27</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">16</span> (line <span class="number">17</span>)</span><br><span class="line"><span class="number">28</span>   <span class="number">0x00000000029312d4</span>: add     rsp,<span class="number">10</span>h</span><br><span class="line"><span class="number">29</span>   <span class="number">0x00000000029312d8</span>: pop     rbp</span><br><span class="line"><span class="number">30</span>   <span class="number">0x00000000029312d9</span>: test    dword ptr [<span class="number">330000</span>h],eax  ;   &#123;poll_return&#125;</span><br><span class="line"><span class="number">31</span>   <span class="number">0x00000000029312df</span>: ret</span><br><span class="line"><span class="number">32</span>   <span class="number">0x00000000029312e0</span>: mov     rax,qword ptr [r15+<span class="number">60</span>h]</span><br><span class="line"><span class="number">33</span>   <span class="number">0x00000000029312e4</span>: mov     r10,rax</span><br><span class="line"><span class="number">34</span>   <span class="number">0x00000000029312e7</span>: add     r10,<span class="number">10</span>h</span><br><span class="line"><span class="number">35</span>   <span class="number">0x00000000029312eb</span>: cmp     r10,qword ptr [r15+<span class="number">70</span>h]</span><br><span class="line"><span class="number">36</span>   <span class="number">0x00000000029312ef</span>: jnb     <span class="number">293135</span>bh</span><br><span class="line"><span class="number">37</span>   <span class="number">0x00000000029312f1</span>: mov     qword ptr [r15+<span class="number">60</span>h],r10</span><br><span class="line"><span class="number">38</span>   <span class="number">0x00000000029312f5</span>: prefetchnta <span class="keyword">byte</span> ptr [r10+<span class="number">0</span>c0h]</span><br><span class="line"><span class="number">39</span>   <span class="number">0x00000000029312fd</span>: mov     r11d,<span class="number">0e07</span>d00b2h   ;   &#123;oop(<span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">40</span>   <span class="number">0x0000000002931303</span>: mov     r10,qword ptr [r12+r11*<span class="number">8</span>+<span class="number">0b0</span>h]</span><br><span class="line"><span class="number">41</span>   <span class="number">0x000000000293130b</span>: mov     qword ptr [rax],r10</span><br><span class="line"><span class="number">42</span>   <span class="number">0x000000000293130e</span>: mov     dword ptr [rax+<span class="number">8</span>h],<span class="number">0e07</span>d00b2h</span><br><span class="line"><span class="number">43</span>                                                 ;   &#123;oop(<span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">44</span>   <span class="number">0x0000000002931315</span>: mov     dword ptr [rax+<span class="number">0</span>ch],r12d</span><br><span class="line"><span class="number">45</span>   <span class="number">0x0000000002931319</span>: mov     rbp,rax           ;*<span class="keyword">new</span>  ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">6</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">46</span>   <span class="number">0x000000000293131c</span>: mov     rdx,rbp</span><br><span class="line"><span class="number">47</span>   <span class="number">0x000000000293131f</span>: call    <span class="number">2907</span>c60h          ; OopMap&#123;rbp=Oop off=<span class="number">132</span>&#125;</span><br><span class="line"><span class="number">48</span>                                                 ;*invokespecial &lt;init&gt;</span><br><span class="line"><span class="number">49</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">10</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">50</span>                                                 ;   &#123;optimized virtual_call&#125;</span><br><span class="line"><span class="number">51</span>   <span class="number">0x0000000002931324</span>: mov     r10,rbp</span><br><span class="line"><span class="number">52</span>   <span class="number">0x0000000002931327</span>: shr     r10,<span class="number">3</span>h</span><br><span class="line"><span class="number">53</span>   <span class="number">0x000000000293132b</span>: mov     r11,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">54</span>   <span class="number">0x0000000002931335</span>: mov     dword ptr [r11+<span class="number">58</span>h],r10d</span><br><span class="line"><span class="number">55</span>   <span class="number">0x0000000002931339</span>: mov     r10,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">56</span>   <span class="number">0x0000000002931343</span>: shr     r10,<span class="number">9</span>h</span><br><span class="line"><span class="number">57</span>   <span class="number">0x0000000002931347</span>: mov     r11d,<span class="number">20</span>b2000h</span><br><span class="line"><span class="number">58</span>   <span class="number">0x000000000293134d</span>: mov     <span class="keyword">byte</span> ptr [r11+r10],r12l</span><br><span class="line"><span class="number">59</span>   <span class="number">0x0000000002931351</span>: lock add dword ptr [rsp],<span class="number">0</span>h  ;*putstatic instance</span><br><span class="line"><span class="number">60</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">13</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">61</span>   <span class="number">0x0000000002931356</span>: jmp     <span class="number">29312</span>bfh</span><br><span class="line"><span class="number">62</span>   <span class="number">0x000000000293135b</span>: mov     rdx,<span class="number">703e80590</span>h    ;   &#123;oop(<span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">63</span>   <span class="number">0x0000000002931365</span>: nop</span><br><span class="line"><span class="number">64</span>   <span class="number">0x0000000002931367</span>: call    <span class="number">292f</span>be0h          ; OopMap&#123;off=<span class="number">204</span>&#125;</span><br><span class="line"><span class="number">65</span>                                                 ;*<span class="keyword">new</span>  ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">6</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">66</span>                                                 ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">67</span>   <span class="number">0x000000000293136c</span>: jmp     <span class="number">2931319</span>h</span><br><span class="line"><span class="number">68</span>   <span class="number">0x000000000293136e</span>: mov     rdx,rax</span><br><span class="line"><span class="number">69</span>   <span class="number">0x0000000002931371</span>: jmp     <span class="number">2931376</span>h</span><br><span class="line"><span class="number">70</span>   <span class="number">0x0000000002931373</span>: mov     rdx,rax           ;*<span class="keyword">new</span>  ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">6</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">71</span>   <span class="number">0x0000000002931376</span>: add     rsp,<span class="number">10</span>h</span><br><span class="line"><span class="number">72</span>   <span class="number">0x000000000293137a</span>: pop     rbp</span><br><span class="line"><span class="number">73</span>   <span class="number">0x000000000293137b</span>: jmp     <span class="number">2932</span>b20h          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">74</span> [Stub Code]</span><br><span class="line"><span class="number">75</span>   <span class="number">0x0000000002931380</span>: mov     rbx,<span class="number">0</span>h            ;   &#123;no_reloc&#125;</span><br><span class="line"><span class="number">76</span>   <span class="number">0x000000000293138a</span>: jmp     <span class="number">293138</span>ah          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">77</span> [Exception Handler]</span><br><span class="line"><span class="number">78</span>   <span class="number">0x000000000293138f</span>: jmp     <span class="number">292f</span>ca0h          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">79</span> [Deopt Handler Code]</span><br><span class="line"><span class="number">80</span>   <span class="number">0x0000000002931394</span>: call    <span class="number">2931399</span>h</span><br><span class="line"><span class="number">81</span>   <span class="number">0x0000000002931399</span>: sub     qword ptr [rsp],<span class="number">5</span>h</span><br><span class="line"><span class="number">82</span>   <span class="number">0x000000000293139e</span>: jmp     <span class="number">2909000</span>h          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">83</span>   <span class="number">0x00000000029313a3</span>: hlt</span><br><span class="line"><span class="number">84</span>   <span class="number">0x00000000029313a4</span>: hlt</span><br><span class="line"><span class="number">85</span>   <span class="number">0x00000000029313a5</span>: hlt</span><br><span class="line"><span class="number">86</span>   <span class="number">0x00000000029313a6</span>: hlt</span><br><span class="line"><span class="number">87</span>   <span class="number">0x00000000029313a7</span>: hlt</span><br></pre></td></tr></table></figure><p>这么长长的汇编代码，可能大家不知道CPU在哪里做了手脚，没事不难，定位到59、60两行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000002931351</span>: lock add dword ptr [rsp],<span class="number">0</span>h  ;*putstatic instance</span><br><span class="line">                                                ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">13</span> (line <span class="number">14</span>)</span><br></pre></td></tr></table></figure><p>之所以定位到这两行是因为这里结尾写明了line 14，line 14即volatile变量instance赋值的地方。后面的add dword ptr [rsp],0h都是正常的汇编语句，意思是将双字节的栈指针寄存器+0，这里的关键就是add前面的lock指令，后面详细分析一下lock指令的作用和为什么加上lock指令后就能保证volatile关键字的内存可见性。</p><p><strong>lock指令做了什么</strong></p><p>之前有说过IA-32架构，关于CPU架构的问题大家有兴趣的可以自己查询一下，这里查询一下IA-32手册关于lock指令的描述，没有IA-32手册的可以去这个地址下载<a href="http://download.csdn.net/detail/andrew_yau/7429355" target="_blank" rel="noopener">IA-32手册下载地址</a>，是个中文版本的手册。</p><p>我摘抄一下IA-32手册中关于lock指令作用的一些描述（因为lock指令的作用在手册中散落在各处，并不是在某一章或者某一节专门讲）： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在修改内存操作时，使用LOCK前缀去调用加锁的读-修改-写操作，这种机制用于多处理器系统中处理器之间进行可靠的通讯，具体描述如下：</span><br><span class="line">（1）在Pentium和早期的IA-32处理器中，LOCK前缀会使处理器执行当前指令时产生一个LOCK#信号，这种总是引起显式总线锁定出现</span><br><span class="line">（2）在Pentium4、Inter Xeon和P6系列处理器中，加锁操作是由高速缓存锁或总线锁来处理。如果内存访问有高速缓存且只影响一个单独的高速缓存行，那么操作中就会调用高速缓存锁，而系统总线和系统内存中的实际区域内不会被锁定。同时，这条总线上的其它Pentium4、Intel Xeon或者P6系列处理器就回写所有已修改的数据并使它们的高速缓存失效，以保证系统内存的一致性。如果内存访问没有高速缓存且/或它跨越了高速缓存行的边界，那么这个处理器就会产生LOCK#信号，并在锁定操作期间不会响应总线控制请求</span><br><span class="line"><span class="number">32</span>位IA-<span class="number">32</span>处理器支持对系统内存中的某个区域进行加锁的原子操作。这些操作常用来管理共享的数据结构（如信号量、段描述符、系统段或页表），两个或多个处理器可能同时会修改这些数据结构中的同一数据域或标志。处理器使用三个相互依赖的机制来实现加锁的原子操作：</span><br><span class="line"><span class="number">1</span>、保证原子操作</span><br><span class="line">2、总线加锁，使用LOCK#信号和LOCK指令前缀</span><br><span class="line"><span class="number">3</span>、高速缓存相干性协议，确保对高速缓存中的数据结构执行原子操作（高速缓存锁）。这种机制存在于Pentium4、Intel Xeon和P6系列处理器中</span><br><span class="line">IA-32处理器提供有一个LOCK#信号，会在某些关键内存操作期间被自动激活，去锁定系统总线。当这个输出信号发出的时候，来自其他处理器或总线代理的控制请求将被阻塞。软件能够通过预先在指令前添加LOCK前缀来指定需要LOCK语义的其它场合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在Intel386、Intel486、Pentium处理器中，明确地对指令加锁会导致LOCK#信号的产生。由硬件设计人员来保证系统硬件中LOCK#信号的可用性，以控制处理器间的内存访问。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于Pentinum4、Intel Xeon以及P6系列处理器，如果被访问的内存区域是在处理器内部进行高速缓存的，那么通常不发出LOCK#信号；相反，加锁只应用于处理器的高速缓存。</span><br></pre></td></tr></table></figure><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">为显式地强制执行LOCK语义，软件可以在下列指令修改内存区域时使用LOCK前缀。当LOCK前缀被置于其它指令之前或者指令没有对内存进行写操作（也就是说目标操作数在寄存器中）时，会产生一个非法操作码异常（#UD）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【1】位测试和修改指令（BTS、BTR、BTC）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【2】交换指令（XADD、CMPXCHG、CMPXCHG8B）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【3】自动假设有LOCK前缀的XCHG指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【4】下列单操作数的算数和逻辑指令：INC、DEC、NOT、NEG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【5】下列双操作数的算数和逻辑指令：ADD、ADC、SUB、SBB、AND、OR、XOR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个加锁的指令会保证对目标操作数所在的内存区域加锁，但是系统可能会将锁定区域解释得稍大一些。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">软件应该使用相同的地址和操作数长度来访问信号量（用作处理器之间发送信号的共享内存）。例如，如果一个处理器使用一个字来访问信号量，其它处理器就不应该使用一个字节来访问这个信号量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总线锁的完整性不收内存区域对齐的影响。加锁语义会一直持续，以满足更新整个操作数所需的总线周期个数。但是，建议加锁访问应该对齐在它们的自然边界上，以提升系统性能：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【1】任何8位访问的边界（加锁或不加锁）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【2】锁定的字访问的16位边界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【3】锁定的双字访问的32位边界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【4】锁定的四字访问的64位边界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对所有其它的内存操作和所有可见的外部事件来说，加锁的操作都是原子的。所有取指令和页表操作能够越过加锁的指令。加锁的指令可用于同步一个处理器写数据而另一个处理器读数据的操作。</span><br></pre></td></tr></table></figure><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">IA-32架构提供了几种机制用来强化或弱化内存排序模型，以处理特殊的编程情形。这些机制包括：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【1】I/O指令、加锁指令、LOCK前缀以及串行化指令等，强制在处理器上进行较强的排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【2】SFENCE指令（在Pentium III中引入）和LFENCE指令、MFENCE指令（在Pentium4和Intel Xeon处理器中引入）提供了某些特殊类型内存操作的排序和串行化功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...（这里还有两条就不写了）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这些机制可以通过下面的方式使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总线上的内存映射设备和其它I/O设备通常对向它们缓冲区写操作的顺序很敏感，I/O指令（IN指令和OUT指令）以下面的方式对这种访问执行强写操作的排序。在执行了一条I/O指令之前，处理器等待之前的所有指令执行完毕以及所有的缓冲区都被都被写入了内存。只有取指令和页表查询能够越过I/O指令，后续指令要等到I/O指令执行完毕才开始执行。</span><br></pre></td></tr></table></figure><p>反复思考IA-32手册对lock指令作用的这几段描述，可以得出lock指令的几个作用：</p><ol><li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存</li><li>lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据</li><li>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序<br>（1）中写了由于效率问题，实际后来的处理器都采用锁缓存来替代锁总线，这种场景下多缓存的数据一致是通过缓存一致性协议来保证的，我们来看一下什么是缓存一致性协议。 </li></ol><p><strong>缓存一致性协议</strong></p><p>讲缓存一致性之前，先说一下<strong>缓存行</strong>的概念：</p><ul><li>缓存是分段（line）的，一个段对应一块存储空间，我们称之为缓存行，它是CPU缓存中可分配的最小存储单元，大小32字节、64字节、128字节不等，这与CPU架构有关，通常来说是64字节。当CPU看到一条读取内存的指令时，它会把内存地址传递给一级数据缓存，一级数据缓存会检查它是否有这个内存地址对应的缓存段，如果没有就把整个缓存段从内存（或更高一级的缓存）中加载进来。注意，这里说的是一次加载整个缓存段，这就是上面提过的局部性原理</li></ul><p>上面说了，LOCK#会锁总线，实际上这不现实，因为锁总线效率太低了。因此最好能做到：使用多组缓存，但是它们的行为看起来只有一组缓存那样。缓存一致性协议就是为了做到这一点而设计的，就像名称所暗示的那样，<strong>这类协议就是要使多组缓存的内容保持一致</strong>。</p><p>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于”嗅探（snooping）”协议，它的基本思想是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个CPU缓存可以读写内存）。</span><br><span class="line">CPU缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其它处理器马上知道这块内存在它们的缓存段中已失效。</span><br></pre></td></tr></table></figure><p>MESI协议是当前最主流的缓存一致性协议，在MESI协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxozdv1j30mt04hmxg.jpg" alt="img"></p><p>这里的I、S和M状态已经有了对应的概念：失效/未载入、干净以及脏的缓存段。所以这里新的知识点只有E状态，代表独占式访问，这个状态解决了”在我们开始修改某块内存之前，我们需要告诉其它处理器”这一问题：只有当缓存行处于E或者M状态时，处理器才能去写它，也就是说只有在这两种状态下，处理器是独占这个缓存行的。当处理器想写某个缓存行时，如果它没有独占权，它必须先发送一条”我要独占权”的请求给总线，<strong>这会通知其它处理器把它们拥有的同一缓存段的拷贝失效</strong>（如果有）。只有在获得独占权后，处理器才能开始修改数据—-并且此时这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。</p><p>反之，如果有其它处理器想读取这个缓存行（马上能知道，因为一直在嗅探总线），独占或已修改的缓存行必须先回到”共享”状态。如果是已修改的缓存行，那么还要先把内容回写到内存中。</p><p><strong>由lock指令回看volatile变量读写</strong></p><p>相信有了上面对于lock的解释，volatile关键字的实现原理应该是一目了然了。首先看一张图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxrs6uwj30gh0dg76s.jpg" alt="img"></p><p>工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。</p><p>那么当写两条线程Thread-A与Threab-B同时操作主存中的一个volatile变量i时，Thread-A写了变量i，那么：</p><ul><li>Thread-A发出LOCK#指令</li><li>发出的LOCK#指令锁总线（或锁缓存行），同时让Thread-B高速缓存中的缓存行内容失效</li><li>Thread-A向主存回写最新修改的i</li></ul><p>Thread-B读取变量i，那么：</p><ul><li>Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值</li></ul><p>由此可以看出，volatile关键字的读和普通变量的读取相比基本没差别，差别主要还是在变量的写操作上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;volatile的用法&quot;&gt;&lt;a href=&quot;#volatile的用法&quot; class=&quot;headerlink&quot; title=&quot;volatile的用法&quot;&gt;&lt;/a&gt;volatile的用法&lt;/h3&gt;&lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
      <category term="Java" scheme="http://nimisora.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis缓存穿透、缓存雪崩、redis并发问题分析</title>
    <link href="http://nimisora.com/post/177SER2.html"/>
    <id>http://nimisora.com/post/177SER2.html</id>
    <published>2020-03-02T10:34:38.000Z</published>
    <updated>2020-03-13T08:44:19.603Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据库" scheme="http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的四个访问修饰符范围</title>
    <link href="http://nimisora.com/post/3R9V3YG.html"/>
    <id>http://nimisora.com/post/3R9V3YG.html</id>
    <published>2020-03-02T10:22:55.000Z</published>
    <updated>2020-03-13T08:43:38.482Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"></th><th><strong>同一个类</strong></th><th><strong>同一个包</strong></th><th><strong>不同包的子类</strong></th><th><strong>不同包的非子类</strong></th></tr></thead><tbody><tr><td align="center">Private</td><td>√</td><td></td><td></td><td></td></tr><tr><td align="center">Default</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td align="center">Protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td align="center">Public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p><strong>public</strong>：Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不<br>　　　　　仅可以跨类访问，而且允许跨包（package）访问。<br><strong>private</strong>: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以<br>　　　　　及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。<br><strong>protect</strong>: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、<br>　　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。<br><strong>default</strong>：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访<br>　　　　　问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;同一个类&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;同一个包&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;不同包的子类&lt;/strong&gt;&lt;/th&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://nimisora.com/categories/Java/"/>
    
      <category term="Java" scheme="http://nimisora.com/categories/Java/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见用例测试</title>
    <link href="http://nimisora.com/post/4NV85Z.html"/>
    <id>http://nimisora.com/post/4NV85Z.html</id>
    <published>2020-03-02T07:54:48.000Z</published>
    <updated>2020-03-12T01:13:55.271Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 如何对一瓶矿泉水瓶进行测试</strong></p><p>根据功能、性能、界面、可靠性、易用性、兼容性、安全性测试方面进行测试，具有条理性。</p><p>功能：</p><ul><li>测试矿泉水瓶的容量是多少，是否与标注相同</li><li>水瓶本身漏不漏水</li><li>水瓶中的水是否能够全部倒出来，还是会在瓶中残留一些</li><li>水瓶拧紧水漏不漏</li></ul><p>性能：</p><ul><li>水瓶里装满水，倒立观察 24 小时，是否漏水</li><li>水瓶盖能够使用多少次，随着次数的增多，螺纹是否会变松</li></ul><p>界面：</p><ul><li>水瓶上的说明是否清楚，什么材质做的，容量是多少</li><li>水瓶上的字体是否容易被抹去</li></ul><p>可靠性：</p><ul><li>水瓶从高处下落会对瓶子本身造成影响</li></ul><p>兼容性：</p><ul><li>水瓶中装其他液体，如酒精、油等是否泄漏，是否与瓶子本身反应</li></ul><p>安全性：</p><ul><li>水瓶装满水在高温或者低温下，是否会因为气压不同而喷开</li><li>水瓶装满水放在冰箱中冷冻是否会裂开</li></ul><p><strong>2. 如何测试共享单车从扫码到开锁这一环节</strong></p><p>功能：</p><ul><li>测试点开扫码界面，是否能够打开相机进行二维码扫描</li><li>测试扫码状态下，手电筒是否能够使用，是否能够转到输入车辆编码模式下</li><li>测试扫描界面是否能够识别二维码</li><li>测试扫描界面是否能够识别出单车是否属于本公司</li><li>测试扫码后，是否能够根据二维码查出车辆是否有问题</li><li>测试扫描后，车辆是否能够开锁成功</li></ul><p>性能：</p><ul><li>多长时间内能够识别出二维码</li><li>多长时间内二维码识别后能够解锁车辆成功</li><li>车锁会不会只开一半，什么情况下会这样</li></ul><p>界面：</p><ul><li>开锁成功后，App 界面是否会显示开锁成功</li><li>开锁失败后，App 界面是否会显示失败原因</li></ul><p>可靠性：</p><ul><li>车辆被扫码 N 次后，故障率是否提高</li><li>手机扫码端扫码 N 次后，不成功率是否提高</li><li>二维码上有灰尘，不清楚，是否能够扫码成功</li></ul><p>兼容性：</p><ul><li>不同手机型号进行扫码，是否都能成功</li><li>不同 App 版本扫码是否都能成功</li><li>不同小程序扫码是否能够成功</li></ul><p>安全性：</p><ul><li>车辆是否会被其他公司程序扫码成功</li><li>车辆没有开锁被移动是否会发出警告</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1. 如何对一瓶矿泉水瓶进行测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据功能、性能、界面、可靠性、易用性、兼容性、安全性测试方面进行测试，具有条理性。&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试矿泉水瓶的容量是多少，是否与标注相同&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="测试" scheme="http://nimisora.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="水" scheme="http://nimisora.com/tags/%E6%B0%B4/"/>
    
      <category term="共享单车" scheme="http://nimisora.com/tags/%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://nimisora.com/post/2BCTX0P.html"/>
    <id>http://nimisora.com/post/2BCTX0P.html</id>
    <published>2020-03-02T07:27:14.000Z</published>
    <updated>2020-03-13T08:47:29.254Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/dolphin0520/p/3919839.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3919839.html</a></p><blockquote><ol><li><strong>单一职责原则SRP</strong>(Single Responsibility Principle)</li></ol></blockquote><p><strong>一个类只负责一个功能领域的相应职责，即就一个类而言，应该只有一个引起它变化的原因。</strong><br> 单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><blockquote><ol start="2"><li><strong>开闭原则OCP</strong>(Open-Closed Principle)</li></ol></blockquote><p><strong>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</strong><br> 在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</strong></p><p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，<strong>抽象化是开闭原则的关键。</strong>可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><p>注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。</p><blockquote><ol start="3"><li><strong>里氏替换原则LSP</strong>(Liskov Substitution Principle)</li></ol></blockquote><p><strong>所有引用父类的地方必须能透明地使用其子类的对象。</strong></p><p>里氏替换原则告诉我们：<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，它不一定能够使用基类对象。</strong></p><p>里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</strong></p><p>在使用里氏替换原则时需要注意如下几个问题：</p><ul><li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类类进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li><li>运用里氏替换原则时，尽量把父类设计为抽象类或接口，让子类继承父类或实现父接口，并实现在父类中的声明的方法，运行时，子类实例替换父类实例，方便扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过一个新的子类来实现。</li><li>Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏替换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</li></ul><blockquote><ol start="4"><li><strong>依赖倒置原则DIP</strong>(Dependency Inversion Principle)</li></ol></blockquote><p><strong>抽象不应该依赖于细节，细节应当依赖于抽象，要针对接口编程，而不是针对实现编程。</strong></p><p>依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口或抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p><p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>在实现依赖倒置原则时，我们需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入（当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。）</strong>的方式注入到其他对象中。</p><blockquote><ol start="5"><li><strong>接口隔离原则ISP</strong>(Interface Segregation Principle)</li></ol></blockquote><p><strong>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</strong></p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong></p><p>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。</p><p>对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p><ol><li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</li><li>如果理解成狭义的特定语言的接口，那么ISP表达的意思是指<strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</strong>在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来并不方便，为了使接口的职责单一，需要将大借口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为”<strong>定制服务</strong>“，即为不同的客户端提供宽窄不同的接口。</li></ol><p><strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</strong>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p><blockquote><ol start="6"><li><strong>迪米特法则LoD</strong>(Law of Demeter)</li></ol></blockquote><p><strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p><p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</strong></p><p>迪米特法则还有几种定义形式，包括：<strong>不要和”陌生人“说话，只与你的直接朋友通信</strong>等，在迪米特法则中，对于一个对象，其朋友包括一下几类：</p><ul><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友“，否则就是”陌生人“。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与”陌生人“发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用，即通过引入一个合理的第三者来降低现有对象之间的耦合度。</strong></p><p>在将迪米特法则运用到系统设计中时，要注意下面几点：</p><ul><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类。</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3919839.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/dolphin0520/p/3919839
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>面试考点回答</title>
    <link href="http://nimisora.com/post/12007PQ.html"/>
    <id>http://nimisora.com/post/12007PQ.html</id>
    <published>2020-03-01T15:27:39.000Z</published>
    <updated>2020-03-01T15:27:39.440Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>URL去重</title>
    <link href="http://nimisora.com/post/24V1B26.html"/>
    <id>http://nimisora.com/post/24V1B26.html</id>
    <published>2020-03-01T14:40:07.000Z</published>
    <updated>2020-03-13T08:41:42.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络爬虫之网页URL去重的5种方法详解"><a href="#网络爬虫之网页URL去重的5种方法详解" class="headerlink" title="网络爬虫之网页URL去重的5种方法详解"></a>网络爬虫之网页URL去重的5种方法详解</h1><p>对网络爬虫有一定了解的小伙伴们应该都知道，网络爬虫在爬取信息的时候，为了避免爬虫爬到重复数据、爬虫陷入死循环等问题，我们就需要对URL去重。</p><p>目录</p><h3 id="1、什么是URL去重？"><a href="#1、什么是URL去重？" class="headerlink" title="1、什么是URL去重？"></a>1、什么是URL去重？</h3><p>字面意思，去除相同的URL，使得爬虫在爬取过程中尽可能少的爬取重复数据。</p><p>2、为什么要进行URL去重？<br>反过来说，就是不对URL进行去重，会产生那些问题呢？</p><p>1、数据重复爬取<br>2、爬虫陷入死循环<br>3、爬取效率低下<br>…..<br>上面的问题是怎么产生的呢？</p><p>首先，我们要明确一点，URL去重是应用于网络爬虫（不知道什么是网络爬虫自己度娘一下）的。</p><h3 id="2-1、先了解爬虫的基本框架："><a href="#2-1、先了解爬虫的基本框架：" class="headerlink" title="2.1、先了解爬虫的基本框架："></a>2.1、先了解爬虫的基本框架：</h3><p>单机版 (这里的单机版指的是一台机器)：</p><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/dandiban.png" alt=""></p><p>单机版中URL去重体现在： 爬取每一个页面前，先看看以前是否已经爬取过这个页面，如果没有爬取过就爬取，否则直接跳过。</p><p>分布式：</p><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/20200301225937.png" alt=""></p><p>分布式爬虫中URL去重体现在：维护一个不重复的请求队列。</p><h3 id="2-2、URL为什么会重复，爬虫又为什么会陷入死循环？"><a href="#2-2、URL为什么会重复，爬虫又为什么会陷入死循环？" class="headerlink" title="2.2、URL为什么会重复，爬虫又为什么会陷入死循环？"></a>2.2、URL为什么会重复，爬虫又为什么会陷入死循环？</h3><p>这里以3个url为例：一个页面中会包括多个超链接，而所有的超链接都是我们可能要爬取的目标。</p><p>我们假设url1中有url2的超链接，url2有url3的超链接，url3又有url1的超链接，那么这三个页面就可以构成下面的关系。</p><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/20200301230000.png" alt=""></p><p>相信聪明的你已经看出了端倪，如果再多几个页面，那么这些页面就形成了一个网（有回路），这是网络爬虫不对url去重而会陷入死循环的原因。</p><p><strong>所以，要想编写出功能强大的网络爬虫，url去重是必不可少的。</strong></p><h3 id="3、URL去重的5种方式"><a href="#3、URL去重的5种方式" class="headerlink" title="3、URL去重的5种方式"></a>3、URL去重的5种方式</h3><p>3.1、列表</p><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/20200301230019.png" alt=""></p><p>列表优点：简单易操作</p><p>缺点：每次添加URL到列表之前，都要先查询一下是否已存在，非常耗费时间和内存空间。</p><h3 id="3-2、set集合"><a href="#3-2、set集合" class="headerlink" title="3.2、set集合"></a>3.2、set集合</h3><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/20200301230038.png" alt=""></p><p>集合优点：对比list来说，省去了过多的查询，节省了一些时间和内存空间</p><p>缺点：耗费内存空间较大，如果有一亿条URL，一个URL50字符：</p><p>100000000 * 50字符 * 2byte / 1024 / 1024 / 1024 约= 9.3GB</p><h3 id="3-3、set-md5"><a href="#3-3、set-md5" class="headerlink" title="3.3、set+md5"></a>3.3、set+md5</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcetk4d1a3j30nl0b6dgw.jpg" alt=""></p><p>优点：对比单纯使用set来说，md5加密方式大大缩小了占用内存空间</p><p>缺点：耗费内存空间还是很大，如果有一亿条URL，一个URL16字节：</p><p>100000000 * 16byte / 1024 / 1024 / 1024 约= 1.4GB</p><h3 id="3-4、bitmap（位图）"><a href="#3-4、bitmap（位图）" class="headerlink" title="3.4、bitmap（位图）"></a>3.4、bitmap（位图）</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcetk454hdj30pz0b6aau.jpg" alt=""><br>优点：对比使用set+md5来说，位图的方式将空间占用缩小到了极限。如果有一亿条URL，一个URL1位： 100000000 / 8bit / 1024 / 1024 / 1024 约= 12M</p><p>缺点：产生哈希冲突的可能性很大。</p><h3 id="3-5、boomfilter-布隆过滤器"><a href="#3-5、boomfilter-布隆过滤器" class="headerlink" title="3.5、boomfilter(布隆过滤器)"></a>3.5、boomfilter(布隆过滤器)</h3><p><img src="https://raw.githubusercontent.com/SoraNimi/Hexo-TC/master/img/Untitled7.png" alt=""></p><p>优点：对比使用bitmap来说，BloomFilter降低了的哈希冲突的出现率。</p><p>缺点：对比bitmap方式来说，BloomFilter较多的耗费内存空间，有一定的误识别率和删除困难。</p><p>不存在漏报（False Negative），即某个元素在某个集合中，肯定能报出来。 可能存在误报（False Positive），即某个元素不在某个集合中，可能也被爆出来。</p><p>总结一下：</p><p>1、list : 简单易操作，耗费内存空间多，耗费资源多</p><p>2、set：比list耗费资源少</p><p>3、set+md5：比set耗费内存空间少（scrapy-redis中使用的就是类似这种的）</p><p>4、bitmap： 耗费内存空间最少，产生hash冲突的概率极大。</p><p>5、boomfilter: 耗费内存空间比bitmap多一点，产生hash冲突的概率比bitmap小一些，但是可能存在误报，而且删除困难。</p><p>最后多说一点：去重是一种思想，去重并不是只能用在url上，还可以用在任何东西上。比如说：爬取100万首音乐，就可以用去重来保证爬取到的音乐的内容不重复。</p><p>————————————————<br>版权声明：本文为CSDN博主「稳步前进的程序猿^_^」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42425970/article/details/102532185" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42425970/article/details/102532185</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络爬虫之网页URL去重的5种方法详解&quot;&gt;&lt;a href=&quot;#网络爬虫之网页URL去重的5种方法详解&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫之网页URL去重的5种方法详解&quot;&gt;&lt;/a&gt;网络爬虫之网页URL去重的5种方法详解&lt;/h1&gt;&lt;p&gt;对网
      
    
    </summary>
    
    
      <category term="项目" scheme="http://nimisora.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="项目" scheme="http://nimisora.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="URL" scheme="http://nimisora.com/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>mybatis预防sql注入</title>
    <link href="http://nimisora.com/post/34W4F6V.html"/>
    <id>http://nimisora.com/post/34W4F6V.html</id>
    <published>2020-03-01T14:21:35.000Z</published>
    <updated>2020-03-13T08:46:55.542Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/jokmangood/p/11705850.html" target="_blank" rel="noopener">https://www.cnblogs.com/jokmangood/p/11705850.html</a></p><h3 id="1、首先看一下下面两个sql语句的区别："><a href="#1、首先看一下下面两个sql语句的区别：" class="headerlink" title="1、首先看一下下面两个sql语句的区别："></a>1、首先看一下下面两个sql语句的区别：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="selectByNameAndPassword" parameterType="java.util.Map" resultMap="BaseResultMap"&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> username = <span class="comment">#&#123;username,jdbcType=VARCHAR&#125;</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">password</span> = <span class="comment">#&#123;password,jdbcType=VARCHAR&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">select</span> <span class="keyword">id</span>=<span class="string">"selectByNameAndPassword"</span> parameterType=<span class="string">"java.util.Map"</span> resultMap=<span class="string">"BaseResultMap"</span>&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> username = $&#123;username,jdbcType=<span class="built_in">VARCHAR</span>&#125;</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">password</span> = $&#123;<span class="keyword">password</span>,jdbcType=<span class="built_in">VARCHAR</span>&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>mybatis中的#和$的区别：</strong></p><p>1、#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。 如：where username=#{username}，如果传入的值是111,那么解析成sql时的值为where username=”111”, 如果传入的值是id，则解析成的sql为where username=”id”. 2、$将传入的数据直接显示生成在sql中。 如：where username=${username}，如果传入的值是111,那么解析成sql时的值为where username=111； 如果传入的值是;drop table user;，则解析成的sql为：select id, username, password, role from user where username=;drop table user; 3、#方式能够很大程度防止sql注入，$方式无法防止Sql注入。 4、$方式一般用于传入数据库对象，例如传入表名. 5、一般能用#的就别用$，若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止sql注入攻击。 6、在MyBatis中，“${xxx}”这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式。所以，这样的参数需要我们在代码中手工进行处理来防止注入。 【结论】在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。</p><h3 id="2、什么是sql注入"><a href="#2、什么是sql注入" class="headerlink" title="2、什么是sql注入"></a>2、什么是sql注入</h3><p><a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener">sql注入解释</a>：是一种代码注入技术，用于攻击数据驱动的应用，恶意的SQL语句被插入到执行的实体字段中（例如，为了转储数据库内容给攻击者）</p><p><strong>SQL注入</strong>，大家都不陌生，是一种常见的攻击方式。<strong>攻击者</strong>在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），有可能入侵<strong>参数检验不足</strong>的应用程序。所以，在我们的应用中需要做一些工作，来防备这样的攻击方式。在一些安全性要求很高的应用中（比如银行软件），经常使用将<strong>SQL语句</strong>全部替换为<strong>存储过程</strong>这样的方式，来防止SQL注入。这当然是<strong>一种很安全的方式</strong>，但我们平时开发中，可能不需要这种死板的方式。</p><h3 id="3、mybatis是如何做到防止sql注入的"><a href="#3、mybatis是如何做到防止sql注入的" class="headerlink" title="3、mybatis是如何做到防止sql注入的"></a>3、mybatis是如何做到防止sql注入的</h3><p><a href="https://mybatis.github.io/mybatis-3/" target="_blank" rel="noopener">MyBatis</a>框架作为一款半自动化的持久层框架，其SQL语句都要我们自己手动编写，这个时候当然需要防止SQL注入。其实，MyBatis的SQL是一个具有“<strong>输入+输出</strong>”的功能，类似于函数的结构，参考上面的两个例子。其中，parameterType表示了输入的参数类型，resultType表示了输出的参数类型。回应上文，如果我们想防止SQL注入，理所当然地要在输入参数上下功夫。上面代码中使用#的即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=? <span class="keyword">and</span> <span class="keyword">password</span>=?</span><br></pre></td></tr></table></figure><p>不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。</p><p>【底层实现原理】MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全的，预编译了的</span></span><br><span class="line">Connection conn = getConn();<span class="comment">//获得连接</span></span><br><span class="line">String sql = <span class="string">"select id, username, password, role from user where id=?"</span>; <span class="comment">//执行sql前会预编译号该条语句</span></span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql); </span><br><span class="line">pstmt.setString(<span class="number">1</span>, id); </span><br><span class="line">ResultSet rs=pstmt.executeUpdate(); </span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>【 <strong>结论</strong>：】</p><p>简单说，#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。 如果我们order by语句后用了${}，那么不做任何处理的时候是存在SQL注入危险的。你说怎么防止，那我只能悲惨的告诉你，你得手动处理过滤一下输入的内容。如判断一下输入的参数的长度是否正常（注入语句一般很长），更精确的过滤则可以查询一下输入的参数是否在预期的参数集合中。</p><h3 id="4、参考文章"><a href="#4、参考文章" class="headerlink" title="4、参考文章"></a>4、参考文章</h3><p><a href="http://blog.csdn.net/yizhenn/article/details/52384601" target="_blank" rel="noopener">http://blog.csdn.net/yizhenn/article/details/52384601</a></p><p><a href="https://www.cnblogs.com/200911/p/5869097.html" target="_blank" rel="noopener">https://www.cnblogs.com/200911/p/5869097.html</a></p><p><a href="http://www.jb51.net/article/95314.htm" target="_blank" rel="noopener">http://www.jb51.net/article/95314.htm</a></p><p>转自：<a href="https://www.cnblogs.com/mmzs/p/8398405.html" target="_blank" rel="noopener">https://www.cnblogs.com/mmzs/p/8398405.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jokmangood/p/11705850.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/jokmangood/p/11705850
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库" scheme="http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mybatis" scheme="http://nimisora.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>预防sql注入</title>
    <link href="http://nimisora.com/post/3NNY5DP.html"/>
    <id>http://nimisora.com/post/3NNY5DP.html</id>
    <published>2020-03-01T14:06:50.000Z</published>
    <updated>2020-03-13T08:47:01.380Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/howitworks/archive/2011/07/25/2116471.html" target="_blank" rel="noopener">https://www.cnblogs.com/howitworks/archive/2011/07/25/2116471.html</a></p><p>说明 ： 以下内容以mysql为例，其他RDBMS原理一样，但数据库原生函数及SQL语法可能有差异。</p><h2 id="一-注入原理"><a href="#一-注入原理" class="headerlink" title="一 注入原理"></a>一 注入原理</h2><p>我们以登录为例,用户登录时后台会执行SQL语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from auth_user where user_name = <span class="string">'$&#123;paramter1&#125;'</span> and password =  <span class="string">'$&#123;paramter2&#125;'</span></span><br></pre></td></tr></table></figure><p>这时如果我们前台传入到后台的参数是以下情况时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;paramter1&#125;=admin  $&#123;paramter2&#125;=<span class="string">' or true  or '</span></span><br></pre></td></tr></table></figure><p>那么后台就会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from auth_user where user_name=<span class="string">'admin'</span> password =<span class="string">' '</span> or <span class="keyword">true</span>  or <span class="string">' '</span> ;</span><br></pre></td></tr></table></figure><p>原本不能查出记录(通过验证)的情况下，通过SQL的注入达到了黑客的目的。</p><p>以上为SQL注入原理，通过SQL注入可以达到，DB的安装目录、DB管理员密码查看等等目的，所以我们在写代码时要养成良好习惯。接下来我们来讲解SQL注入的防范及原理。</p><h2 id="一-防范原理"><a href="#一-防范原理" class="headerlink" title="一 防范原理"></a>一 防范原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String stmtSQL = <span class="string">"select * from auth_user where user_name = ? and password =  ?"</span>;  </span><br><span class="line">         getJdbcTemplate().execute(stmtSQL,<span class="keyword">new</span> PreparedStatementCallback()&#123;  </span><br><span class="line">             <span class="function"><span class="keyword">public</span> Object <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span>  <span class="keyword">throws</span> SQLException  </span></span><br><span class="line"><span class="function">             </span>&#123;  </span><br><span class="line">                 <span class="comment">//$&#123;paramter1&#125;</span></span><br><span class="line">                     ps.setString(<span class="number">1</span>, <span class="string">"admin"</span>);</span><br><span class="line">                 <span class="comment">//$&#123;paramter2&#125;  </span></span><br><span class="line">                     ps.setString(<span class="number">2</span>, <span class="string">" ' ' or true  or ' ' "</span>);  </span><br><span class="line">                     ps.execute();  </span><br><span class="line">              <span class="comment">//test code</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">             &#125;  </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>承上SQL注入例子，如果我们对${paramter} 进行相关的验证就可以达到预防的作用。</p><p>以java为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String stmtSQL = <span class="string">"select * from auth_user where user_name = ? and password =  ?"</span>;  </span><br><span class="line">         getJdbcTemplate().execute(stmtSQL,<span class="keyword">new</span> PreparedStatementCallback()&#123;  </span><br><span class="line">             <span class="function"><span class="keyword">public</span> Object <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span>  <span class="keyword">throws</span> SQLException  </span></span><br><span class="line"><span class="function">             </span>&#123;  </span><br><span class="line">                 <span class="comment">//$&#123;paramter1&#125;</span></span><br><span class="line">                     ps.setString(<span class="number">1</span>, <span class="string">"admin"</span>);</span><br><span class="line">                 <span class="comment">//$&#123;paramter2&#125;  </span></span><br><span class="line">                     ps.setString(<span class="number">2</span>, <span class="string">" ' ' or true  or ' ' "</span>);  </span><br><span class="line">                     ps.execute();  </span><br><span class="line">              <span class="comment">//test code</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">             &#125;  </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这段程序的原理是将SQL语句进行参数话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"insert into auth_user(username,password) values(?,?)"</span></span><br></pre></td></tr></table></figure><p>将其中的”?”进行参数替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$&#123;paramter1&#125;</span></span><br><span class="line">                   ps.setString(<span class="number">1</span>, <span class="string">"admin"</span>);</span><br><span class="line">               <span class="comment">//$&#123;paramter2&#125;  </span></span><br><span class="line">                   ps.setString(<span class="number">2</span>, <span class="string">" ' ' or true  or ' ' "</span>);  </span><br><span class="line">                   ps.execute();</span><br></pre></td></tr></table></figure><p>替换的过程一定要注意将特殊的符号进行转义，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">' = \\'</span></span><br><span class="line"><span class="string">" =\\"</span></span><br></pre></td></tr></table></figure><p>如上程序，最终执行的SQL为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from auth_user where password =<span class="string">' \\'</span> or <span class="keyword">true</span>  or \\<span class="string">' '</span> ;</span><br></pre></td></tr></table></figure><p>结果与我们预期一样。</p><h2 id="一总结"><a href="#一总结" class="headerlink" title="一总结"></a>一总结</h2><p>SQL的注入是数据库的基本知识点，所以防范方法已有很多，但是原理其实很简单：</p><p>1 参数化SQL语句</p><p>2 参数检查，特殊字符进行处理（转义）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/howitworks/archive/2011/07/25/2116471.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/howit
      
    
    </summary>
    
    
      <category term="sql" scheme="http://nimisora.com/categories/sql/"/>
    
      <category term="数据库" scheme="http://nimisora.com/categories/sql/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sql" scheme="http://nimisora.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Git上线流程</title>
    <link href="http://nimisora.com/post/2SRJCNF.html"/>
    <id>http://nimisora.com/post/2SRJCNF.html</id>
    <published>2020-03-01T11:50:17.000Z</published>
    <updated>2020-03-13T08:41:46.015Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Git" scheme="http://nimisora.com/categories/Git/"/>
    
      <category term="项目" scheme="http://nimisora.com/categories/Git/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Git" scheme="http://nimisora.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://nimisora.com/post/2MV7VZ1.html"/>
    <id>http://nimisora.com/post/2MV7VZ1.html</id>
    <published>2020-03-01T09:26:09.000Z</published>
    <updated>2020-03-13T08:41:16.305Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://nimisora.com/categories/Java/"/>
    
      <category term="项目" scheme="http://nimisora.com/categories/Java/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="单点登录" scheme="http://nimisora.com/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>如何使用两个线程交替打印1--100</title>
    <link href="http://nimisora.com/post/1CTB0BQ.html"/>
    <id>http://nimisora.com/post/1CTB0BQ.html</id>
    <published>2020-02-29T09:46:07.000Z</published>
    <updated>2020-03-13T08:41:19.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><ul><li><p>wait():令当前线程放弃了cpu的资源，使别的线程可以访问共享的资源，而当前的线程排队等待，再次对资源的访问</p></li><li><p>notify():唤醒正在排队的等待的同步资源的线程，</p></li><li><p>notifyAll()：唤醒正在排队等待的所有的线程</p></li><li><p>在 java.lang.Object:<br>用这三个方法的注意点：  同步方法或者同步代码块里</p><p>使用两个线程打印1—-100.线程1和线程2交替打印</p></li></ul><p>分析： 1.我先使用两个线程打印1—100，（先不用交替打印） 2.然后在使用上面的三个方法，在代码里添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintNum</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                notify();<span class="comment">//唤醒wait()的一个或者所有线程</span></span><br><span class="line">                <span class="keyword">if</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span></span><br><span class="line">                            + num);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//释放当前的锁，另一个线程就会进来</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">PrintNum p=<span class="keyword">new</span> PrintNum();</span><br><span class="line"></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(p);</span><br><span class="line">Thread t2=<span class="keyword">new</span> Thread(p);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"甲"</span>);</span><br><span class="line">t2.setName(<span class="string">"乙"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      如何使用两个线程交替打印1--100
    
    </summary>
    
    
      <category term="多线程" scheme="http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java单例模式</title>
    <link href="http://nimisora.com/post/23CXE7H.html"/>
    <id>http://nimisora.com/post/23CXE7H.html</id>
    <published>2020-02-29T07:54:48.000Z</published>
    <updated>2020-03-13T08:41:36.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java单例模式"><a href="#Java单例模式" class="headerlink" title="Java单例模式"></a>Java单例模式</h1><p>本文首先概述了单例模式产生动机，揭示了单例模式的本质和应用场景。紧接着，我们给出了单例模式在单线程环境下的两种经典实现：<strong>饿汉式</strong> 和<strong>懒汉式</strong>，但是饿汉式是线程安全的，而懒汉式是非线程安全的。在多线程环境下，我们特别介绍了五种方式来在多线程环境下创建线程安全的单例，即分别使用<strong>synchronized方法</strong>、<strong>synchronized块</strong>、<strong>静态内部类</strong>、<strong>双重检查模式</strong> 和<strong>ThreadLocal</strong> 来实现懒汉式单例，并总结出实现效率高且线程安全的懒汉式单例所需要注意的事项。</p><hr><h1 id="一-单例模式概述"><a href="#一-单例模式概述" class="headerlink" title="一. 单例模式概述"></a><strong>一. 单例模式概述</strong></h1><p><strong>单例模式（Singleton）</strong>，也叫单子模式，是一种常用的设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候，整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，显然，这种方式简化了在复杂环境下的配置管理。</p><p>特别地，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。事实上，这些应用都或多或少具有资源管理器的功能。例如，每台计算机可以有若干个打印机，但只能有一个 Printer Spooler<strong>(单例)</strong> ，以避免两个打印作业同时输出到打印机中。再比如，每台计算机可以有若干通信端口，系统应当集中 <strong>(单例)</strong>管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p><p>综上所述，<strong>单例模式就是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种方法。</strong></p><hr><h1 id="二-单例模式及其单线程环境下的经典实现"><a href="#二-单例模式及其单线程环境下的经典实现" class="headerlink" title="二. 单例模式及其单线程环境下的经典实现"></a><strong>二. 单例模式及其单线程环境下的经典实现</strong></h1><p>单例模式应该是23种设计模式中最简单的一种模式了，下面我们从单例模式的定义、类型、结构和使用要素四个方面来介绍它。</p><p>1、单例模式理论基础</p><p><strong>定义：</strong> <strong>确保一个类只有一个实例，并为整个系统提供一个全局访问点 (向整个系统提供这个实例)。</strong></p><p><strong>类型：</strong> <strong>创建型模式</strong></p><p><strong>结构：</strong></p><p><img src="https://i.loli.net/2020/02/29/noxdZAbsVTX3vUt.jpg" alt="单例模式类图.gif"></p><p>特别地，为了更好地理解上面的类图，我们以此为契机，介绍一下类图的几个知识点：</p><ul><li>类图分为三部分，依次是类名、属性、方法；</li><li>以&lt;&lt;开头和以&gt;&gt;结尾的为注释信息；</li><li>修饰符+代表public，-代表private，#代表protected，什么都没有代表包可见；</li><li>带下划线的属性或方法代表是静态的。</li></ul><p><strong>三要素：</strong></p><ul><li><strong>私有的构造方法；</strong></li><li><strong>指向自己实例的私有静态引用；</strong></li><li><strong>以自己实例为返回值的静态的公有方法。</strong></li></ul><hr><p>2、单线程环境下的两种经典实现</p><p>在介绍单线程环境中单例模式的两种经典实现之前，我们有必要先解释一下 <strong>立即加载</strong> 和<strong>延迟加载</strong> 两个概念。</p><ul><li><p><strong>立即加载 ：</strong> 在类加载初始化的时候就主动创建实例；</p></li><li><p><strong>延迟加载 ：</strong> 等到真正使用的时候才去创建实例，不用时不去主动创建。</p><p>  在单线程环境下，单例模式根据实例化对象时机的不同，有两种经典的实现：一种是 <strong>饿汉式单例(立即加载)</strong>，一种是 <strong>懒汉式单例(延迟加载)</strong>。<strong>饿汉式单例在单例类被加载时候，就实例化一个对象并交给自己的引用；而懒汉式单例只有在真正使用的时候才会实例化一个对象并交给自己的引用。</strong>代码示例分别如下：</p></li></ul><hr><p><strong>饿汉式单例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们知道，<strong>类加载的方式是按需加载，且加载一次。</strong>。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。</li></ul><hr><p><strong>懒汉式单例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们从懒汉式单例可以看到，单例实例被延迟加载，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</li></ul><hr><p><strong>总之，从速度和反应时间角度来讲，饿汉式（又称立即加载）要好一些；从资源利用效率上说，懒汉式（又称延迟加载）要好一些。</strong></p><hr><p>3、单例模式的优点</p><p>我们从单例模式的定义和实现，可以知道单例模式具有以下几个优点：</p><ul><li>在内存中只有一个对象，节省内存空间；</li><li>避免频繁的创建销毁对象，可以提高性能；</li><li>避免对共享资源的多重占用，简化访问；</li><li>为整个系统提供一个全局访问点。</li></ul><hr><p>4、单例模式的使用场景</p><p>由于单例模式具有以上优点，并且形式上比较简单，所以是日常开发中用的比较多的一种设计模式，<strong>其核心在于为整个系统提供一个唯一的实例，</strong>其应用场景包括但不仅限于以下几种：</p><ul><li>有状态的工具类对象；</li><li>频繁访问数据库或文件的对象；</li></ul><hr><p>5、单例模式的注意事项</p><p>在使用单例模式时，我们必须使用单例类提供的公有工厂方法得到单例对象，而不应该使用反射来创建，否则将会实例化一个新对象。此外，在多线程环境下使用单例模式时，应特别注意线程安全问题，我在下文会重点讲到这一点。</p><hr><h1 id="三-多线程环境下单例模式的实现"><a href="#三-多线程环境下单例模式的实现" class="headerlink" title="三. 多线程环境下单例模式的实现"></a><strong>三. 多线程环境下单例模式的实现</strong></h1><p>在单线程环境下，无论是饿汉式单例还是懒汉式单例，它们都能够正常工作。但是，在多线程环境下，情形就发生了变化：由于饿汉式单例天生就是线程安全的，可以直接用于多线程而不会出现问题；但懒汉式单例本身是非线程安全的，因此就会出现多个实例的情况，与单例模式的初衷是相背离的。下面我重点阐述以下几个问题：</p><ul><li>为什么说饿汉式单例天生就是线程安全的？</li><li>传统的懒汉式单例为什么是非线程安全的？</li><li>怎么修改传统的懒汉式单例，使其线程变得安全？</li><li>线程安全的单例的实现还有哪些，怎么实现？</li><li><strong>双重检查模式、Volatile关键字 在单例模式中的应用</strong></li><li><strong>ThreadLocal 在单例模式中的应用</strong></li></ul><hr><p>特别地，为了能够更好的观察到单例模式的实现是否是线程安全的，我们提供了一个简单的<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>程序来验证。该示例程序的判断原理是：</p><p>开启多个线程来分别获取单例，然后打印它们所获取到的单例的hashCode值。若它们获取的单例是相同的(该单例模式的实现是线程安全的)，那么它们的hashCode值一定完全一致；若它们的hashCode值不完全一致，那么获取的单例必定不是同一个，即该单例模式的实现不是线程安全的，是多例的。注意，相应输出结果附在每个单例模式实现示例后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>1、为什么说饿汉式单例天生就是线程安全的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现与上面传统懒汉式单例的实现唯一的差别就在于：<strong>是否使用 synchronized 修饰 getSingleton2()方法。</strong>若使用，就保证了对临界资源的同步互斥访问，也就保证了单例。</p><p>从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低，因为同步块的作用域有点大，而且锁的粒度有点粗。同步方法效率低，那我们考虑使用同步代码块来实现。</p><hr><p><strong>2)、同步延迟加载 — synchronized块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现与上面synchronized方法版本实现类似，此不赘述。从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率仍然比较低，事实上，和使用synchronized方法的版本相比，基本没有任何效率上的提高。    </p><hr><p><strong>3)、同步延迟加载 — 使用内部类实现延迟加载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有内部类，按需加载，用时加载，也就是延迟加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton5 singleton5 = <span class="keyword">new</span> Singleton5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getSingleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Holder.singleton5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output(完全一致):</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><ul><li>如上述代码所示，我们可以使用内部类实现线程安全的懒汉式单例，这种方式也是一种效率比较高的做法。至于其为什么是线程安全的，其与问题 “为什么说饿汉式单例天生就是线程安全的？” 相类似，此不赘述。</li></ul><hr><h1 id="四-单例模式与双重检查-Double-Check-idiom"><a href="#四-单例模式与双重检查-Double-Check-idiom" class="headerlink" title="四. 单例模式与双重检查(Double-Check idiom)"></a><strong>四. 单例模式与双重检查(Double-Check idiom)</strong></h1><p>使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，<strong>其不但保证了单例，而且切实提高了程序运行效率。</strong>对应的代码清单如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用volatile关键字防止重排序，因为 new Instance()是一个非原子操作，</span></span><br><span class="line">    <span class="comment">//可能创建一个不完整的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 singleton3;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getSingleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Double-Check idiom</span></span><br><span class="line">        <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;       <span class="comment">// 1</span></span><br><span class="line">                <span class="comment">// 只需在第一次创建实例时才同步</span></span><br><span class="line">                <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;       <span class="comment">// 2</span></span><br><span class="line">                    singleton3 = <span class="keyword">new</span> Singleton3();      <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Output(完全一致):</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>如上述代码所示，<strong>为了在保证单例的前提下提高运行效率，我们需要对 singleton3 进行第二次检查，目的是避开过多的同步（因为这里的同步只需在第一次创建实例时才同步，一旦创建成功，以后获取实例时就不需要同步获取锁了）。这种做法无疑是优秀的，但是我们必须注意一点</strong>：　<strong>必须使用volatile关键字修饰单例引用。</strong></p><hr><p><strong>那么，如果上述的实现没有使用 volatile 修饰 singleton3，会导致什么情形发生呢？</strong> 为解释该问题，我们分两步来阐述：</p><p><strong>(1)、当我们写了 new 操作，JVM 到底会发生什么？</strong></p><p>首先，我们要明白的是： <strong>new Singleton3() 是一个非原子操作。</strong>代码行singleton3 = new Singleton3(); 的执行过程可以形象地用如下3行伪代码来表示：</p><pre><code>memory = allocate();        //1:分配对象的内存空间ctorInstance(memory);       //2:初始化对象singleton3 = memory;        //3:使singleton3指向刚分配的内存地址</code></pre><p><strong>但实际上，这个过程可能发生无序写入(指令重排序)，也就是说上面的3行指令可能会被重排序导致先执行第3行后执行第2行，</strong>也就是说其真实执行顺序可能是下面这种：</p><pre><code>memory = allocate();        //1:分配对象的内存空间singleton3 = memory;        //3:使singleton3指向刚分配的内存地址ctorInstance(memory);       //2:初始化对象</code></pre><p>这段伪代码演示的情况不仅是可能的，而且是一些 JIT 编译器上真实发生的现象。</p><hr><p><strong>(2)、重排序情景再现</strong>　了解 new 操作是非原子的并且可能发生重排序这一事实后，我们回过头看使用 Double-Check idiom 的同步延迟加载的实现：</p><p>我们需要重新考察上述清单中的 //3 行。<strong>此行代码创建了一个 Singleton 对象并初始化变量 singleton3 来引用此对象。这行代码存在的问题是，在 Singleton 构造函数体执行之前，变量 singleton3 可能提前成为非 null 的，即赋值语句在对象实例化之前调用，此时别的线程将得到的是一个不完整（未初始化）的对象，会导致系统崩溃。</strong>下面是程序可能的一组执行步骤：</p><p>1、线程 1 进入 getSingleton3() 方法；　</p><p>2、由于 singleton3 为 null，线程 1 在 //1 处进入 synchronized 块；</p><p>3、同样由于 singleton3 为 null，线程 1 直接前进到 //3 处，但在构造函数执行之前，使实例成为非 null，并且该实例是未初始化的；</p><p>4、线程 1 被线程 2 预占；</p><p>5、线程 2 检查实例是否为 null。因为实例不为 null，线程 2 得到一个不完整（未初始化）的 Singleton 对象；　</p><p>6、线程 2 被线程 1 预占。</p><p>7、线程 1 通过运行 Singleton3 对象的构造函数来完成对该对象的初始化。</p><p>显然，一旦我们的程序在执行过程中发生了上述情形，就会造成灾难性的后果，而这种安全隐患正是由于指令重排序的问题所导致的。让人兴奋地是，volatile 关键字正好可以完美解决了这个问题。也就是说，我们只需使用volatile关键字修饰单例引用就可以避免上述灾难。</p><hr><h1 id="五-单例模式-与-ThreadLocal"><a href="#五-单例模式-与-ThreadLocal" class="headerlink" title="五. 单例模式 与 ThreadLocal"></a><strong>五. 单例模式 与 ThreadLocal</strong></h1><p>借助于 ThreadLocal，我们可以实现双重检查模式的变体。我们将临界资源线程局部化，具体到本例就是将双重检测的第一层检测条件 <strong>if (instance == null)</strong> 转换为 <strong>线程局部范围</strong>内的操作 。这里的 ThreadLocal 也只是用作标识而已，用来标识每个线程是否已访问过：如果访问过，则不再需要走同步块，这样就提高了一定的效率。对应的代码清单如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式单例</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ThreadLocal 线程局部变量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Singleton4&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Singleton4&gt;();</span><br><span class="line">   <span class="comment">// 不需要是</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getSingleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 第一次检查：该线程是否第一次访问</span></span><br><span class="line">   createSingleton4();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleton4;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSingleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 第二次检查：该单例是否被创建</span></span><br><span class="line">   <span class="comment">// 只执行一次</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将单例放入当前线程的局部变量中</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Output(完全一致):</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>借助于 ThreadLocal，我们也可以实现线程安全的懒汉式单例。但与直接双重检查模式使用，使用ThreadLocal的实现在效率上还不如双重检查锁定。</p><hr><h1 id="六-小结"><a href="#六-小结" class="headerlink" title="六. 小结"></a><strong>六. 小结</strong></h1><p>本文首先介绍了单例模式的定义和结构，并给出了其在单线程和多线程环境下的几种经典实现。特别地，我们知道，<strong>传统的饿汉式单例无论在单线程还是多线程环境下都是线程安全的，但是传统的懒汉式单例在多线程环境下是非线程安全的。</strong>为此，我们特别介绍了五种方式来在多线程环境下创建线程安全的单例，包括：</p><ul><li>使用synchronized方法实现懒汉式单例；</li><li>使用synchronized块实现懒汉式单例；</li><li>使用静态内部类实现懒汉式单例；</li><li>使用双重检查模式实现懒汉式单例；</li><li>使用ThreadLocal实现懒汉式单例；</li></ul><hr><p>当然，实现懒汉式单例还有其他方式。但是，这五种是比较经典的实现，也是我们应该掌握的几种实现方式。从这五种实现中，我们可以总结出，<strong>要想实现效率高的线程安全的单例，我们必须注意以下两点：</strong></p><ul><li><strong>尽量减少同步块的作用域；</strong></li><li><strong>尽量使用细粒度的锁。</strong></li></ul><p>本文转自：<a href="http://my.csdn.net/justloveyou_" target="_blank" rel="noopener">书呆子Rico</a> 的博客<a href="http://blog.csdn.net/justloveyou_/" target="_blank" rel="noopener">http://blog.csdn.net/justloveyou_/article/details/64127789</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java单例模式&quot;&gt;&lt;a href=&quot;#Java单例模式&quot; class=&quot;headerlink&quot; title=&quot;Java单例模式&quot;&gt;&lt;/a&gt;Java单例模式&lt;/h1&gt;&lt;p&gt;本文首先概述了单例模式产生动机，揭示了单例模式的本质和应用场景。紧接着，我们给出了单例模式在
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java/"/>
    
    
      <category term="饱汉" scheme="http://nimisora.com/tags/%E9%A5%B1%E6%B1%89/"/>
    
      <category term="懒汉" scheme="http://nimisora.com/tags/%E6%87%92%E6%B1%89/"/>
    
  </entry>
  
  <entry>
    <title>Java的生产者-消费者模型</title>
    <link href="http://nimisora.com/post/1KJC1GF.html"/>
    <id>http://nimisora.com/post/1KJC1GF.html</id>
    <published>2020-02-29T07:54:48.000Z</published>
    <updated>2020-03-13T08:41:33.229Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="多线程" scheme="http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java/"/>
    
    
      <category term="生产者" scheme="http://nimisora.com/tags/%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    
      <category term="消费者" scheme="http://nimisora.com/tags/%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>头条面试1</title>
    <link href="http://nimisora.com/post/3Q8345K.html"/>
    <id>http://nimisora.com/post/3Q8345K.html</id>
    <published>2020-02-29T04:26:09.000Z</published>
    <updated>2020-02-29T04:32:24.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。举例：<br>nums = {-1,1,1,1},<br>那么你应该返回的是：1。因为这个数组所有数的平方取值都是1，只有一种取值<br>nums = {-1,0,1,2,3}<br>你应该返回4，因为nums数组所有元素的平方值一共4种取值：1,0,4,9</p><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>使用双指针，从两边向中间扫描。将绝对值大的数字删掉，计数即可，并记录刚才删除的数值的绝对值，以免出现多次相同的数据，重复计数的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareUniqueNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = ver.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="built_in">abs</span>(ver[<span class="number">0</span>]);  <span class="comment">///记录上次删除数据的绝对值</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;    <span class="comment">///数字为 1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="comment">///每次删除绝对值较大的数字，并记录下删除是数字的绝对值，绝对值相同的只计数一次</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(ver[i]) &gt; <span class="built_in">abs</span>(ver[j])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="built_in">abs</span>(ver[i])) &#123; <span class="comment">///如果没有删过</span></span><br><span class="line">                num++;</span><br><span class="line">                pre = <span class="built_in">abs</span>(ver[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="built_in">abs</span>(ver[j])) &#123; <span class="comment">///如果没有删过</span></span><br><span class="line">                num++;</span><br><span class="line">                pre = <span class="built_in">abs</span>(ver[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ver</span><span class="params">(&#123;<span class="number">-5</span>, <span class="number">-3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> num = squareUniqueNum(ver);    <span class="comment">///求有序数组中数字平方后，消重结果中数字的个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;p&gt;给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://nimisora.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="头条" scheme="http://nimisora.com/tags/%E5%A4%B4%E6%9D%A1/"/>
    
  </entry>
  
</feed>
