<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>深入理解Volatile关键字及其实现原理 | Hexo</title><meta name="description" content="深入理解Volatile关键字及其实现原理"><meta name="author" content="SoraNimi"><meta name="copyright" content="SoraNimi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="深入理解Volatile关键字及其实现原理"><meta name="twitter:description" content="深入理解Volatile关键字及其实现原理"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="深入理解Volatile关键字及其实现原理"><meta property="og:url" content="http://yoursite.com/2020/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="深入理解Volatile关键字及其实现原理"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><link rel="next" title="Redis缓存穿透、缓存雪崩、redis并发问题分析" href="http://yoursite.com/2020/03/02/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81redis%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hexo</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/02/20/4xYWkCrlbtKU8ey.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile的用法"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">volatile的用法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile的原理"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">volatile的原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile与可见性"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">volatile与可见性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile与有序性"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">volatile与有序性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile与原子性"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">volatile与原子性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile的用法"><span class="toc-number">1.</span> <span class="toc-text">volatile的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile的原理"><span class="toc-number">2.</span> <span class="toc-text">volatile的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile与可见性"><span class="toc-number">3.</span> <span class="toc-text">volatile与可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile与有序性"><span class="toc-number">4.</span> <span class="toc-text">volatile与有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile与原子性"><span class="toc-number">5.</span> <span class="toc-text">volatile与原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。"><span class="toc-number">6.</span> <span class="toc-text">原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">深入理解Volatile关键字及其实现原理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-03-05<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-03-05</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3 id="volatile的用法"><a href="#volatile的用法" class="headerlink" title="volatile的用法"></a>volatile的用法</h3><p>转载自：<a href="https://blog.csdn.net/zezezuiaiya/article/details/81456060" target="_blank" rel="noopener">https://blog.csdn.net/zezezuiaiya/article/details/81456060</a></p>
<p>volatile通常被比喻成”轻量级的synchronized”，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p>
<p>volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</p>
<p>如以下代码，是一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰可能被多个线程同时访问到的singleton。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h3><p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p>
<p>但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p>
<p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</p>
<p>缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p>所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p>
<h3 id="volatile与可见性"><a href="#volatile与可见性" class="headerlink" title="volatile与可见性"></a>volatile与可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。</p>
<p>前面的关于volatile的原理中介绍过了，Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p>
<h3 id="volatile与有序性"><a href="#volatile与有序性" class="headerlink" title="volatile与有序性"></a>volatile与有序性</h3><p>有序性即程序执行的顺序按照代码的先后顺序执行。</p>
<p>除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p>
<p>而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。</p>
<p>普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。</p>
<p>volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-&gt;add-&gt;save 的执行顺序就是：load、add、save。</p>
<h3 id="volatile与原子性"><a href="#volatile与原子性" class="headerlink" title="volatile与原子性"></a>volatile与原子性</h3><h3 id="原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。"><a href="#原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。" class="headerlink" title="原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。"></a>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</h3><p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</p>
<p>为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。</p>
<p>所以，volatile是不能保证原子性的。</p>
<p>在以下两个场景中可以使用volatile来代替synchronized：</p>
<p>1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。</p>
<p>2、变量不需要与其他状态变量共同参与不变约束。</p>
<p>除以上场景外，都需要使用其他方式来保证原子性，如synchronized或者concurrent包。</p>
<p>我们来看一下volatile和原子性的例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码比较简单，就是创建10个线程，然后分别执行1000次i++操作。正常情况下，程序的输出结果应该是10000，但是，多次执行的结果都小于10000。这其实就是volatile无法满足原子性的原因。</p>
<p>为什么会出现这种情况呢，那就是因为虽然volatile可以保证inc在多个线程之间的可见性。但是无法inc++的原子性。</p>
<p>总结与思考<br>我们介绍过了volatile关键字和synchronized关键字。现在我们知道，synchronized可以保证原子性、有序性和可见性。而volatile却只能保证有序性和可见性。</p>
<p>-————————————————————————————————————————-</p>
<p><strong>前言</strong></p>
<p>我们知道volatile关键字的作用是保证变量在多线程之间的可见性，它是java.util.concurrent包的核心，没有volatile就没有这么多的并发类给我们使用。</p>
<p>本文详细解读一下volatile关键字如何保证变量在多线程之间的可见性，在此之前，有必要讲解一下CPU缓存的相关知识，掌握这部分知识一定会让我们更好地理解volatile的原理，从而更好、更正确地地使用volatile关键字。</p>
<p><strong>CPU缓存</strong></p>
<p><strong>CPU缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾</strong>，因为CPU运算速度要比内存读写速度快得多，举个例子：</p>
<ul>
<li>一次主内存的访问通常在几十到几百个时钟周期</li>
<li>一次L1高速缓存的读写只需要1~2个时钟周期</li>
<li>一次L2高速缓存的读写也只需要数十个时钟周期</li>
</ul>
<p>这种访问速度的显著差异，导致CPU可能会花费很长时间等待数据到来或把数据写入内存。</p>
<p>基于此，现在CPU大多数情况下读写都不会直接访问内存（CPU都没有连接到内存的管脚），取而代之的是CPU缓存，CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。</p>
<p>按照读取顺序与CPU结合的紧密程度，CPU缓存可分为：</p>
<ul>
<li>一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存</li>
<li>二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半</li>
<li>三级缓存：简称L3 Cache，部分高端CPU才有</li>
</ul>
<p>每一级缓存中所存储的数据全部都是下一级缓存中的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也相对递增。</p>
<p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有再从二级缓存中查找，如果还是没有再从三级缓存中或内存中查找。一般来说每级缓存的命中率大概都有80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。</p>
<p><strong>使用CPU缓存带来的问题</strong></p>
<p>用一张图表示一下CPU–&gt;CPU缓存–&gt;主内存数据读取之间的关系：</p>
<p><a href="https://tva1.sinaimg.cn/large/00831rSTly1gcitxquqxcj309q06x3yh.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxquqxcj309q06x3yh.jpg" class="lazyload"></a></p>
<p>当系统运行时，CPU执行计算的过程如下：</p>
<ol>
<li>程序以及数据被加载到主内存</li>
<li>指令和数据被加载到CPU缓存</li>
<li>CPU执行指令，把结果写到高速缓存</li>
<li>高速缓存中的数据写回主内存</li>
</ol>
<p>如果服务器是单核CPU，那么这些步骤不会有任何的问题，但是如果服务器是多核CPU，那么问题来了，以Intel Core i7处理器的高速缓存概念模型为例（图片摘自《深入理解计算机系统》）：</p>
<p><a href="https://tva1.sinaimg.cn/large/00831rSTly1gcitxmqg8ej30fd0eo0z1.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxmqg8ej30fd0eo0z1.jpg" class="lazyload"></a></p>
<p>试想下面一种情况：</p>
<ol>
<li>核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存</li>
<li>核3做了上面同样的工作，这样核0与核3的缓存拥有同样的数据</li>
<li>核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存</li>
<li>核3访问该字节，由于核0并未将数据写回主存，数据不同步</li>
</ol>
<p>为了解决这个问题，CPU制造商制定了一个规则：<strong>当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效</strong>。于是，在上面的情况下，核3发现自己的缓存中数据已无效，核0将立即把自己的数据写回主存，然后核3重新读取该数据。</p>
<p><strong>反汇编Java字节码，查看汇编层面对volatile关键字做了什么</strong></p>
<p>有了上面的理论基础，我们可以研究volatile关键字到底是如何实现的。首先写一段简单的代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2  * <span class="doctag">@author</span> 五月的仓颉http://www.cnblogs.com/xrq730/p/7048693.html</span></span><br><span class="line"><span class="comment"> 3  */</span></span><br><span class="line"> <span class="number">4</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">7</span>     </span><br><span class="line"> <span class="number">8</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">10</span>             instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"><span class="number">11</span>         &#125;</span><br><span class="line"><span class="number">12</span>         </span><br><span class="line"><span class="number">13</span>         <span class="keyword">return</span> instance;</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     </span><br><span class="line"><span class="number">16</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">17</span>         LazySingleton.getInstance();</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     </span><br><span class="line"><span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure></div>

<p>首先反编译一下这段代码的.class文件，看一下生成的字节码：</p>
<p><a href="https://tva1.sinaimg.cn/large/00831rSTly1gcitxmt6u4j30m808h75y.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxmt6u4j30m808h75y.jpg" class="lazyload"></a></p>
<p>没有任何特别的。要知道，字节码指令，比如上图的getstatic、ifnonnull、new等，最终对应到操作系统的层面，都是转换为一条一条指令去执行，我们使用的PC机、应用服务器的CPU架构通常都是IA-32架构的，这种架构采用的指令集是CISC（复杂指令集），而汇编语言则是这种指令集的助记符。</p>
<p>因此，既然在字节码层面我们看不出什么端倪，那下面就看看将代码转换为汇编指令能看出什么端倪。Windows上要看到以上代码对应的汇编码不难（吐槽一句，说说不难，为了这个问题我找遍了各种资料，差点就准备安装虚拟机，在Linux系统上搞了），访问<a href="https://sourceforge.net/projects/fcml/files/fcml-1.1.1/hsdis-1.1.1-win32-amd64.zip/download" target="_blank" rel="noopener">hsdis工具路径</a>可直接下载hsdis工具，下载完毕之后解压，将hsdis-amd64.dll与hsdis-amd64.lib两个文件放在%JAVA_HOME%\jre\bin\server路径下即可，如下图：</p>
<p><a href="https://tva1.sinaimg.cn/large/00831rSTly1gcitxo2bryj30v809d0yx.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxo2bryj30v809d0yx.jpg" class="lazyload"></a></p>
<p>然后跑main函数，跑main函数之前，加入如下虚拟机参数：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*LazySingleton.getInstance</span><br></pre></td></tr></table></figure></div>

<p>运行main函数即可，代码生成的汇编指令为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span> <span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: PrintAssembly is enabled</span>; turning on DebugNonSafepoints to gain additional output</span><br><span class="line"> <span class="number">2</span> CompilerOracle: compileonly *LazySingleton.getInstance</span><br><span class="line"> <span class="number">3</span> Loaded disassembler from D:\JDK\jre\bin\server\hsdis-amd64.dll</span><br><span class="line"> <span class="number">4</span> Decoding compiled method <span class="number">0x0000000002931150</span>:</span><br><span class="line"> <span class="number">5</span> Code:</span><br><span class="line"> <span class="number">6</span> Argument <span class="number">0</span> is unknown.RIP: <span class="number">0x29312a0</span> Code size: <span class="number">0x00000108</span></span><br><span class="line"> <span class="number">7</span> [Disassembling <span class="keyword">for</span> mach=<span class="string">'amd64'</span>]</span><br><span class="line"> <span class="number">8</span> [Entry Point]</span><br><span class="line"> <span class="number">9</span> [Verified Entry Point]</span><br><span class="line"><span class="number">10</span> [Constants]</span><br><span class="line">11   # &#123;method&#125; 'getInstance' '()Lorg/xrq/test/design/singleton/LazySingleton;' in 'org/xrq/test/design/singleton/LazySingleton'</span><br><span class="line">12   #           [sp+0x20]  (sp of caller)</span><br><span class="line"><span class="number">13</span>   <span class="number">0x00000000029312a0</span>: mov     dword ptr [rsp+<span class="number">0f</span>fffffffffffa000h],eax</span><br><span class="line"><span class="number">14</span>   <span class="number">0x00000000029312a7</span>: push    rbp</span><br><span class="line"><span class="number">15</span>   <span class="number">0x00000000029312a8</span>: sub     rsp,<span class="number">10</span>h           ;*synchronization entry</span><br><span class="line"><span class="number">16</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@-<span class="number">1</span> (line <span class="number">13</span>)</span><br><span class="line"><span class="number">17</span>   <span class="number">0x00000000029312ac</span>: mov     r10,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">18</span>   <span class="number">0x00000000029312b6</span>: mov     r11d,dword ptr [r10+<span class="number">58</span>h]</span><br><span class="line"><span class="number">19</span>                                                 ;*getstatic instance</span><br><span class="line"><span class="number">20</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">0</span> (line <span class="number">13</span>)</span><br><span class="line"><span class="number">21</span>   <span class="number">0x00000000029312ba</span>: test    r11d,r11d</span><br><span class="line"><span class="number">22</span>   <span class="number">0x00000000029312bd</span>: je      <span class="number">29312e0</span>h</span><br><span class="line"><span class="number">23</span>   <span class="number">0x00000000029312bf</span>: mov     r10,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">24</span>   <span class="number">0x00000000029312c9</span>: mov     r11d,dword ptr [r10+<span class="number">58</span>h]</span><br><span class="line"><span class="number">25</span>   <span class="number">0x00000000029312cd</span>: mov     rax,r11</span><br><span class="line"><span class="number">26</span>   <span class="number">0x00000000029312d0</span>: shl     rax,<span class="number">3</span>h            ;*getstatic instance</span><br><span class="line"><span class="number">27</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">16</span> (line <span class="number">17</span>)</span><br><span class="line"><span class="number">28</span>   <span class="number">0x00000000029312d4</span>: add     rsp,<span class="number">10</span>h</span><br><span class="line"><span class="number">29</span>   <span class="number">0x00000000029312d8</span>: pop     rbp</span><br><span class="line"><span class="number">30</span>   <span class="number">0x00000000029312d9</span>: test    dword ptr [<span class="number">330000</span>h],eax  ;   &#123;poll_return&#125;</span><br><span class="line"><span class="number">31</span>   <span class="number">0x00000000029312df</span>: ret</span><br><span class="line"><span class="number">32</span>   <span class="number">0x00000000029312e0</span>: mov     rax,qword ptr [r15+<span class="number">60</span>h]</span><br><span class="line"><span class="number">33</span>   <span class="number">0x00000000029312e4</span>: mov     r10,rax</span><br><span class="line"><span class="number">34</span>   <span class="number">0x00000000029312e7</span>: add     r10,<span class="number">10</span>h</span><br><span class="line"><span class="number">35</span>   <span class="number">0x00000000029312eb</span>: cmp     r10,qword ptr [r15+<span class="number">70</span>h]</span><br><span class="line"><span class="number">36</span>   <span class="number">0x00000000029312ef</span>: jnb     <span class="number">293135</span>bh</span><br><span class="line"><span class="number">37</span>   <span class="number">0x00000000029312f1</span>: mov     qword ptr [r15+<span class="number">60</span>h],r10</span><br><span class="line"><span class="number">38</span>   <span class="number">0x00000000029312f5</span>: prefetchnta <span class="keyword">byte</span> ptr [r10+<span class="number">0</span>c0h]</span><br><span class="line"><span class="number">39</span>   <span class="number">0x00000000029312fd</span>: mov     r11d,<span class="number">0e07</span>d00b2h   ;   &#123;oop(<span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">40</span>   <span class="number">0x0000000002931303</span>: mov     r10,qword ptr [r12+r11*<span class="number">8</span>+<span class="number">0b0</span>h]</span><br><span class="line"><span class="number">41</span>   <span class="number">0x000000000293130b</span>: mov     qword ptr [rax],r10</span><br><span class="line"><span class="number">42</span>   <span class="number">0x000000000293130e</span>: mov     dword ptr [rax+<span class="number">8</span>h],<span class="number">0e07</span>d00b2h</span><br><span class="line"><span class="number">43</span>                                                 ;   &#123;oop(<span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">44</span>   <span class="number">0x0000000002931315</span>: mov     dword ptr [rax+<span class="number">0</span>ch],r12d</span><br><span class="line"><span class="number">45</span>   <span class="number">0x0000000002931319</span>: mov     rbp,rax           ;*<span class="keyword">new</span>  ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">6</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">46</span>   <span class="number">0x000000000293131c</span>: mov     rdx,rbp</span><br><span class="line"><span class="number">47</span>   <span class="number">0x000000000293131f</span>: call    <span class="number">2907</span>c60h          ; OopMap&#123;rbp=Oop off=<span class="number">132</span>&#125;</span><br><span class="line"><span class="number">48</span>                                                 ;*invokespecial &lt;init&gt;</span><br><span class="line"><span class="number">49</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">10</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">50</span>                                                 ;   &#123;optimized virtual_call&#125;</span><br><span class="line"><span class="number">51</span>   <span class="number">0x0000000002931324</span>: mov     r10,rbp</span><br><span class="line"><span class="number">52</span>   <span class="number">0x0000000002931327</span>: shr     r10,<span class="number">3</span>h</span><br><span class="line"><span class="number">53</span>   <span class="number">0x000000000293132b</span>: mov     r11,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">54</span>   <span class="number">0x0000000002931335</span>: mov     dword ptr [r11+<span class="number">58</span>h],r10d</span><br><span class="line"><span class="number">55</span>   <span class="number">0x0000000002931339</span>: mov     r10,<span class="number">7</span>ada9e428h    ;   &#123;oop(a <span class="string">'java/lang/Class'</span> = <span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">56</span>   <span class="number">0x0000000002931343</span>: shr     r10,<span class="number">9</span>h</span><br><span class="line"><span class="number">57</span>   <span class="number">0x0000000002931347</span>: mov     r11d,<span class="number">20</span>b2000h</span><br><span class="line"><span class="number">58</span>   <span class="number">0x000000000293134d</span>: mov     <span class="keyword">byte</span> ptr [r11+r10],r12l</span><br><span class="line"><span class="number">59</span>   <span class="number">0x0000000002931351</span>: lock add dword ptr [rsp],<span class="number">0</span>h  ;*putstatic instance</span><br><span class="line"><span class="number">60</span>                                                 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">13</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">61</span>   <span class="number">0x0000000002931356</span>: jmp     <span class="number">29312</span>bfh</span><br><span class="line"><span class="number">62</span>   <span class="number">0x000000000293135b</span>: mov     rdx,<span class="number">703e80590</span>h    ;   &#123;oop(<span class="string">'org/xrq/test/design/singleton/LazySingleton'</span>)&#125;</span><br><span class="line"><span class="number">63</span>   <span class="number">0x0000000002931365</span>: nop</span><br><span class="line"><span class="number">64</span>   <span class="number">0x0000000002931367</span>: call    <span class="number">292f</span>be0h          ; OopMap&#123;off=<span class="number">204</span>&#125;</span><br><span class="line"><span class="number">65</span>                                                 ;*<span class="keyword">new</span>  ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">6</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">66</span>                                                 ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">67</span>   <span class="number">0x000000000293136c</span>: jmp     <span class="number">2931319</span>h</span><br><span class="line"><span class="number">68</span>   <span class="number">0x000000000293136e</span>: mov     rdx,rax</span><br><span class="line"><span class="number">69</span>   <span class="number">0x0000000002931371</span>: jmp     <span class="number">2931376</span>h</span><br><span class="line"><span class="number">70</span>   <span class="number">0x0000000002931373</span>: mov     rdx,rax           ;*<span class="keyword">new</span>  ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">6</span> (line <span class="number">14</span>)</span><br><span class="line"><span class="number">71</span>   <span class="number">0x0000000002931376</span>: add     rsp,<span class="number">10</span>h</span><br><span class="line"><span class="number">72</span>   <span class="number">0x000000000293137a</span>: pop     rbp</span><br><span class="line"><span class="number">73</span>   <span class="number">0x000000000293137b</span>: jmp     <span class="number">2932</span>b20h          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">74</span> [Stub Code]</span><br><span class="line"><span class="number">75</span>   <span class="number">0x0000000002931380</span>: mov     rbx,<span class="number">0</span>h            ;   &#123;no_reloc&#125;</span><br><span class="line"><span class="number">76</span>   <span class="number">0x000000000293138a</span>: jmp     <span class="number">293138</span>ah          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">77</span> [Exception Handler]</span><br><span class="line"><span class="number">78</span>   <span class="number">0x000000000293138f</span>: jmp     <span class="number">292f</span>ca0h          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">79</span> [Deopt Handler Code]</span><br><span class="line"><span class="number">80</span>   <span class="number">0x0000000002931394</span>: call    <span class="number">2931399</span>h</span><br><span class="line"><span class="number">81</span>   <span class="number">0x0000000002931399</span>: sub     qword ptr [rsp],<span class="number">5</span>h</span><br><span class="line"><span class="number">82</span>   <span class="number">0x000000000293139e</span>: jmp     <span class="number">2909000</span>h          ;   &#123;runtime_call&#125;</span><br><span class="line"><span class="number">83</span>   <span class="number">0x00000000029313a3</span>: hlt</span><br><span class="line"><span class="number">84</span>   <span class="number">0x00000000029313a4</span>: hlt</span><br><span class="line"><span class="number">85</span>   <span class="number">0x00000000029313a5</span>: hlt</span><br><span class="line"><span class="number">86</span>   <span class="number">0x00000000029313a6</span>: hlt</span><br><span class="line"><span class="number">87</span>   <span class="number">0x00000000029313a7</span>: hlt</span><br></pre></td></tr></table></figure></div>
<p>这么长长的汇编代码，可能大家不知道CPU在哪里做了手脚，没事不难，定位到59、60两行：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000002931351</span>: lock add dword ptr [rsp],<span class="number">0</span>h  ;*putstatic instance</span><br><span class="line">                                                ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">13</span> (line <span class="number">14</span>)</span><br></pre></td></tr></table></figure></div>


<p>之所以定位到这两行是因为这里结尾写明了line 14，line 14即volatile变量instance赋值的地方。后面的add dword ptr [rsp],0h都是正常的汇编语句，意思是将双字节的栈指针寄存器+0，这里的关键就是add前面的lock指令，后面详细分析一下lock指令的作用和为什么加上lock指令后就能保证volatile关键字的内存可见性。</p>
<p><strong>lock指令做了什么</strong></p>
<p>之前有说过IA-32架构，关于CPU架构的问题大家有兴趣的可以自己查询一下，这里查询一下IA-32手册关于lock指令的描述，没有IA-32手册的可以去这个地址下载<a href="http://download.csdn.net/detail/andrew_yau/7429355" target="_blank" rel="noopener">IA-32手册下载地址</a>，是个中文版本的手册。</p>
<p>我摘抄一下IA-32手册中关于lock指令作用的一些描述（因为lock指令的作用在手册中散落在各处，并不是在某一章或者某一节专门讲）： </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在修改内存操作时，使用LOCK前缀去调用加锁的读-修改-写操作，这种机制用于多处理器系统中处理器之间进行可靠的通讯，具体描述如下：</span><br><span class="line">（1）在Pentium和早期的IA-32处理器中，LOCK前缀会使处理器执行当前指令时产生一个LOCK#信号，这种总是引起显式总线锁定出现</span><br><span class="line">（2）在Pentium4、Inter Xeon和P6系列处理器中，加锁操作是由高速缓存锁或总线锁来处理。如果内存访问有高速缓存且只影响一个单独的高速缓存行，那么操作中就会调用高速缓存锁，而系统总线和系统内存中的实际区域内不会被锁定。同时，这条总线上的其它Pentium4、Intel Xeon或者P6系列处理器就回写所有已修改的数据并使它们的高速缓存失效，以保证系统内存的一致性。如果内存访问没有高速缓存且/或它跨越了高速缓存行的边界，那么这个处理器就会产生LOCK#信号，并在锁定操作期间不会响应总线控制请求</span><br><span class="line"><span class="number">32</span>位IA-<span class="number">32</span>处理器支持对系统内存中的某个区域进行加锁的原子操作。这些操作常用来管理共享的数据结构（如信号量、段描述符、系统段或页表），两个或多个处理器可能同时会修改这些数据结构中的同一数据域或标志。处理器使用三个相互依赖的机制来实现加锁的原子操作：</span><br><span class="line"><span class="number">1</span>、保证原子操作</span><br><span class="line">2、总线加锁，使用LOCK#信号和LOCK指令前缀</span><br><span class="line"><span class="number">3</span>、高速缓存相干性协议，确保对高速缓存中的数据结构执行原子操作（高速缓存锁）。这种机制存在于Pentium4、Intel Xeon和P6系列处理器中</span><br><span class="line">IA-32处理器提供有一个LOCK#信号，会在某些关键内存操作期间被自动激活，去锁定系统总线。当这个输出信号发出的时候，来自其他处理器或总线代理的控制请求将被阻塞。软件能够通过预先在指令前添加LOCK前缀来指定需要LOCK语义的其它场合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在Intel386、Intel486、Pentium处理器中，明确地对指令加锁会导致LOCK#信号的产生。由硬件设计人员来保证系统硬件中LOCK#信号的可用性，以控制处理器间的内存访问。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于Pentinum4、Intel Xeon以及P6系列处理器，如果被访问的内存区域是在处理器内部进行高速缓存的，那么通常不发出LOCK#信号；相反，加锁只应用于处理器的高速缓存。</span><br></pre></td></tr></table></figure></div>

<p><a href="https://common.cnblogs.com/images/copycode.gif" target="_blank" rel="noopener" data-fancybox="group" data-caption="复制代码" class="fancybox"><img alt="复制代码" title="复制代码" data-src="https://common.cnblogs.com/images/copycode.gif" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">为显式地强制执行LOCK语义，软件可以在下列指令修改内存区域时使用LOCK前缀。当LOCK前缀被置于其它指令之前或者指令没有对内存进行写操作（也就是说目标操作数在寄存器中）时，会产生一个非法操作码异常（#UD）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【1】位测试和修改指令（BTS、BTR、BTC）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【2】交换指令（XADD、CMPXCHG、CMPXCHG8B）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【3】自动假设有LOCK前缀的XCHG指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【4】下列单操作数的算数和逻辑指令：INC、DEC、NOT、NEG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【5】下列双操作数的算数和逻辑指令：ADD、ADC、SUB、SBB、AND、OR、XOR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个加锁的指令会保证对目标操作数所在的内存区域加锁，但是系统可能会将锁定区域解释得稍大一些。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">软件应该使用相同的地址和操作数长度来访问信号量（用作处理器之间发送信号的共享内存）。例如，如果一个处理器使用一个字来访问信号量，其它处理器就不应该使用一个字节来访问这个信号量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总线锁的完整性不收内存区域对齐的影响。加锁语义会一直持续，以满足更新整个操作数所需的总线周期个数。但是，建议加锁访问应该对齐在它们的自然边界上，以提升系统性能：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【1】任何8位访问的边界（加锁或不加锁）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【2】锁定的字访问的16位边界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【3】锁定的双字访问的32位边界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【4】锁定的四字访问的64位边界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对所有其它的内存操作和所有可见的外部事件来说，加锁的操作都是原子的。所有取指令和页表操作能够越过加锁的指令。加锁的指令可用于同步一个处理器写数据而另一个处理器读数据的操作。</span><br></pre></td></tr></table></figure></div>

<p><a href="https://common.cnblogs.com/images/copycode.gif" target="_blank" rel="noopener" data-fancybox="group" data-caption="复制代码" class="fancybox"><img alt="复制代码" title="复制代码" data-src="https://common.cnblogs.com/images/copycode.gif" class="lazyload"></a></p>
<p><a href="https://common.cnblogs.com/images/copycode.gif" target="_blank" rel="noopener" data-fancybox="group" data-caption="复制代码" class="fancybox"><img alt="复制代码" title="复制代码" data-src="https://common.cnblogs.com/images/copycode.gif" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">IA-32架构提供了几种机制用来强化或弱化内存排序模型，以处理特殊的编程情形。这些机制包括：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【1】I/O指令、加锁指令、LOCK前缀以及串行化指令等，强制在处理器上进行较强的排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【2】SFENCE指令（在Pentium III中引入）和LFENCE指令、MFENCE指令（在Pentium4和Intel Xeon处理器中引入）提供了某些特殊类型内存操作的排序和串行化功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...（这里还有两条就不写了）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这些机制可以通过下面的方式使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总线上的内存映射设备和其它I/O设备通常对向它们缓冲区写操作的顺序很敏感，I/O指令（IN指令和OUT指令）以下面的方式对这种访问执行强写操作的排序。在执行了一条I/O指令之前，处理器等待之前的所有指令执行完毕以及所有的缓冲区都被都被写入了内存。只有取指令和页表查询能够越过I/O指令，后续指令要等到I/O指令执行完毕才开始执行。</span><br></pre></td></tr></table></figure></div>

<p>反复思考IA-32手册对lock指令作用的这几段描述，可以得出lock指令的几个作用：</p>
<ol>
<li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存</li>
<li>lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据</li>
<li>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序<br>（1）中写了由于效率问题，实际后来的处理器都采用锁缓存来替代锁总线，这种场景下多缓存的数据一致是通过缓存一致性协议来保证的，我们来看一下什么是缓存一致性协议。 </li>
</ol>
<p><strong>缓存一致性协议</strong></p>
<p>讲缓存一致性之前，先说一下<strong>缓存行</strong>的概念：</p>
<ul>
<li>缓存是分段（line）的，一个段对应一块存储空间，我们称之为缓存行，它是CPU缓存中可分配的最小存储单元，大小32字节、64字节、128字节不等，这与CPU架构有关，通常来说是64字节。当CPU看到一条读取内存的指令时，它会把内存地址传递给一级数据缓存，一级数据缓存会检查它是否有这个内存地址对应的缓存段，如果没有就把整个缓存段从内存（或更高一级的缓存）中加载进来。注意，这里说的是一次加载整个缓存段，这就是上面提过的局部性原理</li>
</ul>
<p>上面说了，LOCK#会锁总线，实际上这不现实，因为锁总线效率太低了。因此最好能做到：使用多组缓存，但是它们的行为看起来只有一组缓存那样。缓存一致性协议就是为了做到这一点而设计的，就像名称所暗示的那样，<strong>这类协议就是要使多组缓存的内容保持一致</strong>。</p>
<p>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于”嗅探（snooping）”协议，它的基本思想是：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个CPU缓存可以读写内存）。</span><br><span class="line">CPU缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其它处理器马上知道这块内存在它们的缓存段中已失效。</span><br></pre></td></tr></table></figure></div>

<p>MESI协议是当前最主流的缓存一致性协议，在MESI协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：</p>
<p><a href="https://tva1.sinaimg.cn/large/00831rSTly1gcitxozdv1j30mt04hmxg.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxozdv1j30mt04hmxg.jpg" class="lazyload"></a></p>
<p>这里的I、S和M状态已经有了对应的概念：失效/未载入、干净以及脏的缓存段。所以这里新的知识点只有E状态，代表独占式访问，这个状态解决了”在我们开始修改某块内存之前，我们需要告诉其它处理器”这一问题：只有当缓存行处于E或者M状态时，处理器才能去写它，也就是说只有在这两种状态下，处理器是独占这个缓存行的。当处理器想写某个缓存行时，如果它没有独占权，它必须先发送一条”我要独占权”的请求给总线，<strong>这会通知其它处理器把它们拥有的同一缓存段的拷贝失效</strong>（如果有）。只有在获得独占权后，处理器才能开始修改数据—-并且此时这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。</p>
<p>反之，如果有其它处理器想读取这个缓存行（马上能知道，因为一直在嗅探总线），独占或已修改的缓存行必须先回到”共享”状态。如果是已修改的缓存行，那么还要先把内容回写到内存中。</p>
<p><strong>由lock指令回看volatile变量读写</strong></p>
<p>相信有了上面对于lock的解释，volatile关键字的实现原理应该是一目了然了。首先看一张图：</p>
<p><a href="https://tva1.sinaimg.cn/large/00831rSTly1gcitxrs6uwj30gh0dg76s.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcitxrs6uwj30gh0dg76s.jpg" class="lazyload"></a></p>
<p>工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。</p>
<p>那么当写两条线程Thread-A与Threab-B同时操作主存中的一个volatile变量i时，Thread-A写了变量i，那么：</p>
<ul>
<li>Thread-A发出LOCK#指令</li>
<li>发出的LOCK#指令锁总线（或锁缓存行），同时让Thread-B高速缓存中的缓存行内容失效</li>
<li>Thread-A向主存回写最新修改的i</li>
</ul>
<p>Thread-B读取变量i，那么：</p>
<ul>
<li>Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值</li>
</ul>
<p>由此可以看出，volatile关键字的读和普通变量的读取相比基本没差别，差别主要还是在变量的写操作上。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">SoraNimi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">http://yoursite.com/2020/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/03/02/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81redis%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Redis缓存穿透、缓存雪崩、redis并发问题分析</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By SoraNimi</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a><span>蜀ICP备20003774号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>