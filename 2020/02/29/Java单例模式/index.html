<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Java单例模式 | Hexo</title><meta name="description" content="Java单例模式"><meta name="keywords" content="饱汉,懒汉"><meta name="author" content="SoraNimi"><meta name="copyright" content="SoraNimi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java单例模式"><meta name="twitter:description" content="Java单例模式"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="Java单例模式"><meta property="og:url" content="http://yoursite.com/2020/02/29/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Java单例模式"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/02/29/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"><link rel="prev" title="Java的生产者-消费者模型" href="http://yoursite.com/2020/02/29/Java%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"><link rel="next" title="HashMap和HashTable的区别" href="http://yoursite.com/2020/02/29/HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hexo</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/02/20/4xYWkCrlbtKU8ey.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java单例模式"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Java单例模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#一-单例模式概述"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">一. 单例模式概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二-单例模式及其单线程环境下的经典实现"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">二. 单例模式及其单线程环境下的经典实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#三-多线程环境下单例模式的实现"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">三. 多线程环境下单例模式的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#四-单例模式与双重检查-Double-Check-idiom"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">四. 单例模式与双重检查(Double-Check idiom)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#五-单例模式-与-ThreadLocal"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">五. 单例模式 与 ThreadLocal</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#六-小结"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">六. 小结</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java单例模式"><span class="toc-number">1.</span> <span class="toc-text">Java单例模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一-单例模式概述"><span class="toc-number">2.</span> <span class="toc-text">一. 单例模式概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二-单例模式及其单线程环境下的经典实现"><span class="toc-number">3.</span> <span class="toc-text">二. 单例模式及其单线程环境下的经典实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三-多线程环境下单例模式的实现"><span class="toc-number">4.</span> <span class="toc-text">三. 多线程环境下单例模式的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四-单例模式与双重检查-Double-Check-idiom"><span class="toc-number">5.</span> <span class="toc-text">四. 单例模式与双重检查(Double-Check idiom)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五-单例模式-与-ThreadLocal"><span class="toc-number">6.</span> <span class="toc-text">五. 单例模式 与 ThreadLocal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六-小结"><span class="toc-number">7.</span> <span class="toc-text">六. 小结</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Java单例模式</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-02-29<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-03-01</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Java单例模式"><a href="#Java单例模式" class="headerlink" title="Java单例模式"></a>Java单例模式</h1><p>本文首先概述了单例模式产生动机，揭示了单例模式的本质和应用场景。紧接着，我们给出了单例模式在单线程环境下的两种经典实现：<strong>饿汉式</strong> 和<strong>懒汉式</strong>，但是饿汉式是线程安全的，而懒汉式是非线程安全的。在多线程环境下，我们特别介绍了五种方式来在多线程环境下创建线程安全的单例，即分别使用<strong>synchronized方法</strong>、<strong>synchronized块</strong>、<strong>静态内部类</strong>、<strong>双重检查模式</strong> 和<strong>ThreadLocal</strong> 来实现懒汉式单例，并总结出实现效率高且线程安全的懒汉式单例所需要注意的事项。</p>
<hr>
<h1 id="一-单例模式概述"><a href="#一-单例模式概述" class="headerlink" title="一. 单例模式概述"></a><strong>一. 单例模式概述</strong></h1><p><strong>单例模式（Singleton）</strong>，也叫单子模式，是一种常用的设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候，整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，显然，这种方式简化了在复杂环境下的配置管理。</p>
<p>特别地，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。事实上，这些应用都或多或少具有资源管理器的功能。例如，每台计算机可以有若干个打印机，但只能有一个 Printer Spooler<strong>(单例)</strong> ，以避免两个打印作业同时输出到打印机中。再比如，每台计算机可以有若干通信端口，系统应当集中 <strong>(单例)</strong>管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>
<p>综上所述，<strong>单例模式就是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种方法。</strong></p>
<hr>
<h1 id="二-单例模式及其单线程环境下的经典实现"><a href="#二-单例模式及其单线程环境下的经典实现" class="headerlink" title="二. 单例模式及其单线程环境下的经典实现"></a><strong>二. 单例模式及其单线程环境下的经典实现</strong></h1><p>单例模式应该是23种设计模式中最简单的一种模式了，下面我们从单例模式的定义、类型、结构和使用要素四个方面来介绍它。</p>
<p>1、单例模式理论基础</p>
<p><strong>定义：</strong> <strong>确保一个类只有一个实例，并为整个系统提供一个全局访问点 (向整个系统提供这个实例)。</strong></p>
<p><strong>类型：</strong> <strong>创建型模式</strong></p>
<p><strong>结构：</strong></p>
<p><a href="https://i.loli.net/2020/02/29/noxdZAbsVTX3vUt.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="单例模式类图.gif" class="fancybox"><img alt="单例模式类图.gif" title="单例模式类图.gif" data-src="https://i.loli.net/2020/02/29/noxdZAbsVTX3vUt.jpg" class="lazyload"></a></p>
<p>特别地，为了更好地理解上面的类图，我们以此为契机，介绍一下类图的几个知识点：</p>
<ul>
<li>类图分为三部分，依次是类名、属性、方法；</li>
<li>以&lt;&lt;开头和以&gt;&gt;结尾的为注释信息；</li>
<li>修饰符+代表public，-代表private，#代表protected，什么都没有代表包可见；</li>
<li>带下划线的属性或方法代表是静态的。</li>
</ul>
<p><strong>三要素：</strong></p>
<ul>
<li><strong>私有的构造方法；</strong></li>
<li><strong>指向自己实例的私有静态引用；</strong></li>
<li><strong>以自己实例为返回值的静态的公有方法。</strong></li>
</ul>
<hr>
<p>2、单线程环境下的两种经典实现</p>
<p>在介绍单线程环境中单例模式的两种经典实现之前，我们有必要先解释一下 <strong>立即加载</strong> 和<strong>延迟加载</strong> 两个概念。</p>
<ul>
<li><p><strong>立即加载 ：</strong> 在类加载初始化的时候就主动创建实例；</p>
</li>
<li><p><strong>延迟加载 ：</strong> 等到真正使用的时候才去创建实例，不用时不去主动创建。</p>
<p>  在单线程环境下，单例模式根据实例化对象时机的不同，有两种经典的实现：一种是 <strong>饿汉式单例(立即加载)</strong>，一种是 <strong>懒汉式单例(延迟加载)</strong>。<strong>饿汉式单例在单例类被加载时候，就实例化一个对象并交给自己的引用；而懒汉式单例只有在真正使用的时候才会实例化一个对象并交给自己的引用。</strong>代码示例分别如下：</p>
</li>
</ul>
<hr>
<p><strong>饿汉式单例：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>我们知道，<strong>类加载的方式是按需加载，且加载一次。</strong>。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。</li>
</ul>
<hr>
<p><strong>懒汉式单例：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>我们从懒汉式单例可以看到，单例实例被延迟加载，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</li>
</ul>
<hr>
<p><strong>总之，从速度和反应时间角度来讲，饿汉式（又称立即加载）要好一些；从资源利用效率上说，懒汉式（又称延迟加载）要好一些。</strong></p>
<hr>
<p>3、单例模式的优点</p>
<p>我们从单例模式的定义和实现，可以知道单例模式具有以下几个优点：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁的创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用，简化访问；</li>
<li>为整个系统提供一个全局访问点。</li>
</ul>
<hr>
<p>4、单例模式的使用场景</p>
<p>由于单例模式具有以上优点，并且形式上比较简单，所以是日常开发中用的比较多的一种设计模式，<strong>其核心在于为整个系统提供一个唯一的实例，</strong>其应用场景包括但不仅限于以下几种：</p>
<ul>
<li>有状态的工具类对象；</li>
<li>频繁访问数据库或文件的对象；</li>
</ul>
<hr>
<p>5、单例模式的注意事项</p>
<p>在使用单例模式时，我们必须使用单例类提供的公有工厂方法得到单例对象，而不应该使用反射来创建，否则将会实例化一个新对象。此外，在多线程环境下使用单例模式时，应特别注意线程安全问题，我在下文会重点讲到这一点。</p>
<hr>
<h1 id="三-多线程环境下单例模式的实现"><a href="#三-多线程环境下单例模式的实现" class="headerlink" title="三. 多线程环境下单例模式的实现"></a><strong>三. 多线程环境下单例模式的实现</strong></h1><p>在单线程环境下，无论是饿汉式单例还是懒汉式单例，它们都能够正常工作。但是，在多线程环境下，情形就发生了变化：由于饿汉式单例天生就是线程安全的，可以直接用于多线程而不会出现问题；但懒汉式单例本身是非线程安全的，因此就会出现多个实例的情况，与单例模式的初衷是相背离的。下面我重点阐述以下几个问题：</p>
<ul>
<li>为什么说饿汉式单例天生就是线程安全的？</li>
<li>传统的懒汉式单例为什么是非线程安全的？</li>
<li>怎么修改传统的懒汉式单例，使其线程变得安全？</li>
<li>线程安全的单例的实现还有哪些，怎么实现？</li>
<li><strong>双重检查模式、Volatile关键字 在单例模式中的应用</strong></li>
<li><strong>ThreadLocal 在单例模式中的应用</strong></li>
</ul>
<hr>
<p>特别地，为了能够更好的观察到单例模式的实现是否是线程安全的，我们提供了一个简单的<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>程序来验证。该示例程序的判断原理是：</p>
<p>开启多个线程来分别获取单例，然后打印它们所获取到的单例的hashCode值。若它们获取的单例是相同的(该单例模式的实现是线程安全的)，那么它们的hashCode值一定完全一致；若它们的hashCode值不完全一致，那么获取的单例必定不是同一个，即该单例模式的实现不是线程安全的，是多例的。注意，相应输出结果附在每个单例模式实现示例后。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>1、为什么说饿汉式单例天生就是线程安全的？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该实现与上面传统懒汉式单例的实现唯一的差别就在于：<strong>是否使用 synchronized 修饰 getSingleton2()方法。</strong>若使用，就保证了对临界资源的同步互斥访问，也就保证了单例。</p>
<p>从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低，因为同步块的作用域有点大，而且锁的粒度有点粗。同步方法效率低，那我们考虑使用同步代码块来实现。</p>
<hr>
<p><strong>2)、同步延迟加载 — synchronized块</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 singleton1 = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getSingleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该实现与上面synchronized方法版本实现类似，此不赘述。从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率仍然比较低，事实上，和使用synchronized方法的版本相比，基本没有任何效率上的提高。    </p>
<hr>
<p><strong>3)、同步延迟加载 — 使用内部类实现延迟加载</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有内部类，按需加载，用时加载，也就是延迟加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton5 singleton5 = <span class="keyword">new</span> Singleton5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getSingleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Holder.singleton5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output(完全一致):</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">482535999</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></div>


<ul>
<li>如上述代码所示，我们可以使用内部类实现线程安全的懒汉式单例，这种方式也是一种效率比较高的做法。至于其为什么是线程安全的，其与问题 “为什么说饿汉式单例天生就是线程安全的？” 相类似，此不赘述。</li>
</ul>
<hr>
<h1 id="四-单例模式与双重检查-Double-Check-idiom"><a href="#四-单例模式与双重检查-Double-Check-idiom" class="headerlink" title="四. 单例模式与双重检查(Double-Check idiom)"></a><strong>四. 单例模式与双重检查(Double-Check idiom)</strong></h1><p>使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，<strong>其不但保证了单例，而且切实提高了程序运行效率。</strong>对应的代码清单如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用volatile关键字防止重排序，因为 new Instance()是一个非原子操作，</span></span><br><span class="line">    <span class="comment">//可能创建一个不完整的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 singleton3;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getSingleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Double-Check idiom</span></span><br><span class="line">        <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;       <span class="comment">// 1</span></span><br><span class="line">                <span class="comment">// 只需在第一次创建实例时才同步</span></span><br><span class="line">                <span class="keyword">if</span> (singleton3 == <span class="keyword">null</span>) &#123;       <span class="comment">// 2</span></span><br><span class="line">                    singleton3 = <span class="keyword">new</span> Singleton3();      <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Output(完全一致):</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    1104499981</span></span><br><span class="line"><span class="comment">    */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></div>






<p>如上述代码所示，<strong>为了在保证单例的前提下提高运行效率，我们需要对 singleton3 进行第二次检查，目的是避开过多的同步（因为这里的同步只需在第一次创建实例时才同步，一旦创建成功，以后获取实例时就不需要同步获取锁了）。这种做法无疑是优秀的，但是我们必须注意一点</strong>：　<strong>必须使用volatile关键字修饰单例引用。</strong></p>
<hr>
<p><strong>那么，如果上述的实现没有使用 volatile 修饰 singleton3，会导致什么情形发生呢？</strong> 为解释该问题，我们分两步来阐述：</p>
<p><strong>(1)、当我们写了 new 操作，JVM 到底会发生什么？</strong></p>
<p>首先，我们要明白的是： <strong>new Singleton3() 是一个非原子操作。</strong>代码行singleton3 = new Singleton3(); 的执行过程可以形象地用如下3行伪代码来表示：</p>
<pre><code>memory = allocate();        //1:分配对象的内存空间
ctorInstance(memory);       //2:初始化对象
singleton3 = memory;        //3:使singleton3指向刚分配的内存地址</code></pre><p><strong>但实际上，这个过程可能发生无序写入(指令重排序)，也就是说上面的3行指令可能会被重排序导致先执行第3行后执行第2行，</strong>也就是说其真实执行顺序可能是下面这种：</p>
<pre><code>memory = allocate();        //1:分配对象的内存空间
singleton3 = memory;        //3:使singleton3指向刚分配的内存地址
ctorInstance(memory);       //2:初始化对象</code></pre><p>这段伪代码演示的情况不仅是可能的，而且是一些 JIT 编译器上真实发生的现象。</p>
<hr>
<p><strong>(2)、重排序情景再现</strong>　了解 new 操作是非原子的并且可能发生重排序这一事实后，我们回过头看使用 Double-Check idiom 的同步延迟加载的实现：</p>
<p>我们需要重新考察上述清单中的 //3 行。<strong>此行代码创建了一个 Singleton 对象并初始化变量 singleton3 来引用此对象。这行代码存在的问题是，在 Singleton 构造函数体执行之前，变量 singleton3 可能提前成为非 null 的，即赋值语句在对象实例化之前调用，此时别的线程将得到的是一个不完整（未初始化）的对象，会导致系统崩溃。</strong>下面是程序可能的一组执行步骤：</p>
<p>1、线程 1 进入 getSingleton3() 方法；　</p>
<p>2、由于 singleton3 为 null，线程 1 在 //1 处进入 synchronized 块；</p>
<p>3、同样由于 singleton3 为 null，线程 1 直接前进到 //3 处，但在构造函数执行之前，使实例成为非 null，并且该实例是未初始化的；</p>
<p>4、线程 1 被线程 2 预占；</p>
<p>5、线程 2 检查实例是否为 null。因为实例不为 null，线程 2 得到一个不完整（未初始化）的 Singleton 对象；　</p>
<p>6、线程 2 被线程 1 预占。</p>
<p>7、线程 1 通过运行 Singleton3 对象的构造函数来完成对该对象的初始化。</p>
<p>显然，一旦我们的程序在执行过程中发生了上述情形，就会造成灾难性的后果，而这种安全隐患正是由于指令重排序的问题所导致的。让人兴奋地是，volatile 关键字正好可以完美解决了这个问题。也就是说，我们只需使用volatile关键字修饰单例引用就可以避免上述灾难。</p>
<hr>
<h1 id="五-单例模式-与-ThreadLocal"><a href="#五-单例模式-与-ThreadLocal" class="headerlink" title="五. 单例模式 与 ThreadLocal"></a><strong>五. 单例模式 与 ThreadLocal</strong></h1><p>借助于 ThreadLocal，我们可以实现双重检查模式的变体。我们将临界资源线程局部化，具体到本例就是将双重检测的第一层检测条件 <strong>if (instance == null)</strong> 转换为 <strong>线程局部范围</strong>内的操作 。这里的 ThreadLocal 也只是用作标识而已，用来标识每个线程是否已访问过：如果访问过，则不再需要走同步块，这样就提高了一定的效率。对应的代码清单如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式单例</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ThreadLocal 线程局部变量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Singleton4&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Singleton4&gt;();</span><br><span class="line">   <span class="comment">// 不需要是</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getSingleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 第一次检查：该线程是否第一次访问</span></span><br><span class="line">   createSingleton4();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singleton4;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSingleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 第二次检查：该单例是否被创建</span></span><br><span class="line">   <span class="comment">// 只执行一次</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将单例放入当前线程的局部变量中</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Output(完全一致):</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   1028355155</span></span><br><span class="line"><span class="comment">   */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></div>



<p>借助于 ThreadLocal，我们也可以实现线程安全的懒汉式单例。但与直接双重检查模式使用，使用ThreadLocal的实现在效率上还不如双重检查锁定。</p>
<hr>
<h1 id="六-小结"><a href="#六-小结" class="headerlink" title="六. 小结"></a><strong>六. 小结</strong></h1><p>本文首先介绍了单例模式的定义和结构，并给出了其在单线程和多线程环境下的几种经典实现。特别地，我们知道，<strong>传统的饿汉式单例无论在单线程还是多线程环境下都是线程安全的，但是传统的懒汉式单例在多线程环境下是非线程安全的。</strong>为此，我们特别介绍了五种方式来在多线程环境下创建线程安全的单例，包括：</p>
<ul>
<li>使用synchronized方法实现懒汉式单例；</li>
<li>使用synchronized块实现懒汉式单例；</li>
<li>使用静态内部类实现懒汉式单例；</li>
<li>使用双重检查模式实现懒汉式单例；</li>
<li>使用ThreadLocal实现懒汉式单例；</li>
</ul>
<hr>
<p>当然，实现懒汉式单例还有其他方式。但是，这五种是比较经典的实现，也是我们应该掌握的几种实现方式。从这五种实现中，我们可以总结出，<strong>要想实现效率高的线程安全的单例，我们必须注意以下两点：</strong></p>
<ul>
<li><strong>尽量减少同步块的作用域；</strong></li>
<li><strong>尽量使用细粒度的锁。</strong></li>
</ul>
<p>本文转自：<a href="http://my.csdn.net/justloveyou_" target="_blank" rel="noopener">书呆子Rico</a> 的博客<a href="http://blog.csdn.net/justloveyou_/" target="_blank" rel="noopener">http://blog.csdn.net/justloveyou_/article/details/64127789</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">SoraNimi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/29/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">http://yoursite.com/2020/02/29/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A5%B1%E6%B1%89/">饱汉    </a><a class="post-meta__tags" href="/tags/%E6%87%92%E6%B1%89/">懒汉    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/29/Java%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Java的生产者-消费者模型</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/29/HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>HashMap和HashTable的区别</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By SoraNimi</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a><span>蜀ICP备20003774号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>