{"meta":{"title":"Hexo","subtitle":"","description":"","author":"SoraNimi","url":"http://nimisora.com","root":"/"},"pages":[{"title":"","date":"2020-03-05T07:23:05.785Z","updated":"2020-03-05T07:23:05.785Z","comments":true,"path":"baidu_verify_BdKvI7D8Ns.html","permalink":"http://nimisora.com/baidu_verify_BdKvI7D8Ns.html","excerpt":"","text":"BdKvI7D8Ns"},{"title":"Gallery","date":"2020-02-20T16:26:33.000Z","updated":"2020-02-20T16:26:33.516Z","comments":true,"path":"Gallery/index.html","permalink":"http://nimisora.com/Gallery/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-12T02:13:38.730Z","updated":"2020-03-11T01:13:51.848Z","comments":false,"path":"about/index.html","permalink":"http://nimisora.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"movies","date":"2020-02-20T16:26:04.000Z","updated":"2020-02-20T16:26:04.645Z","comments":true,"path":"movies/index.html","permalink":"http://nimisora.com/movies/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-11T06:36:47.407Z","updated":"2020-03-11T01:13:51.848Z","comments":false,"path":"categories/index.html","permalink":"http://nimisora.com/categories/index.html","excerpt":"","text":""},{"title":"music","date":"2020-02-20T16:25:53.000Z","updated":"2020-02-20T16:25:53.634Z","comments":true,"path":"music/index.html","permalink":"http://nimisora.com/music/index.html","excerpt":"","text":""},{"title":"友情鏈接","date":"2018-06-07T14:17:49.000Z","updated":"2020-02-20T15:51:00.182Z","comments":true,"path":"link/index.html","permalink":"http://nimisora.com/link/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-11T01:51:14.576Z","updated":"2020-03-11T01:51:14.576Z","comments":false,"path":"repository/index.html","permalink":"http://nimisora.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-11T06:36:47.417Z","updated":"2020-03-11T01:13:51.849Z","comments":false,"path":"tags/index.html","permalink":"http://nimisora.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"二叉树中和为某一值的路径","slug":"剑指offer/二叉树中和为某一值的路径","date":"2020-03-14T14:14:40.000Z","updated":"2020-03-14T14:31:20.272Z","comments":true,"path":"post/3ZYPPMZ.html","link":"","permalink":"http://nimisora.com/post/3ZYPPMZ.html","excerpt":"","text":"二叉树中和为某一值的路径输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; cur=new ArrayList&lt;&gt;(); helper(root,target,cur,res); //因为需要返回的数组中数组长度大的在前面，所以使用Collecions.sore,结合lamda表达 //式进行排序 Collections.sort(res,new Comparator&lt;ArrayList&lt;Integer&gt;&gt;()&#123; @Override public int compare(ArrayList&lt;Integer&gt;o1,ArrayList&lt;Integer&gt;o2)&#123; if(o1.size()&lt;o2.size())&#123; return 1; &#125; else &#123; return -1; &#125; &#125; &#125;); return res;&#125;public void helper(TreeNode root,int target,ArrayList&lt;Integer&gt;cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)&#123; if(root==null)&#123; return; &#125; int value=root.val; cur.add(value); if(target==value&amp;&amp;root.left==null&amp;&amp;root.right==null)&#123; //注意，在这里需要add函数中new一个实例，不然最后传入的是空数组 res.add(new ArrayList(cur)); &#125; else &#123; helper(root.left,target-value,cur,res); helper(root.right,target-value,cur,res); &#125; cur.remove(cur.size()-1);&#125;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://nimisora.com/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[]},{"title":"23.合并K个排序链表","slug":"Leetcode/23合并K个排序链表","date":"2020-03-13T08:50:01.000Z","updated":"2020-03-13T08:55:54.901Z","comments":true,"path":"post/3Y651F0.html","link":"","permalink":"http://nimisora.com/post/3Y651F0.html","excerpt":"","text":"合并K个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例： 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: struct cmp &#123; bool operator()(ListNode *a, ListNode *b) &#123; return a-&gt;val &gt; b-&gt;val; &#125; &#125;; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode *head = nullptr; ListNode **ppcur = &amp;head; priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, cmp&gt; pq; for (auto list : lists) &#123; if (list) pq.emplace(list); &#125; while (!pq.empty()) &#123; auto cur = pq.top(); pq.pop(); *ppcur = cur; if (cur-&gt;next) &#123; pq.emplace(cur-&gt;next); &#125; ppcur = &amp;(*ppcur)-&gt;next; &#125; return head; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://nimisora.com/categories/Leetcode/"}],"tags":[{"name":"优先队列","slug":"优先队列","permalink":"http://nimisora.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}]},{"title":"Java创建线程的四种方式","slug":"Java/Java创建线程的四种方式","date":"2020-03-12T07:54:48.000Z","updated":"2020-03-13T01:17:30.655Z","comments":true,"path":"post/3A03G67.html","link":"","permalink":"http://nimisora.com/post/3A03G67.html","excerpt":"","text":"1、启动线程方式： 要启动的可以分为两类：返回结果和不返回结果。对于这两种，也分别有两种启动线程的方式： 1）继承Thread类，implements Runnable接口 2）实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的线程 第一种：继承Thread类创建方程Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。 123456789101112public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"is running!\");&#125; public static void main(String[] args) &#123; MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.start(); myThread2.start(); &#125;&#125; 结果： 12Thread-0is running!Thread-1is running! 2、实现Runnable接口创建线程 如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口，如下： 123456789101112131415public class MyThread implements Runnable &#123; @Overridepublic void run() &#123; System.out.println(Thread.currentThread().getName()+\" is Running!\");&#125; public static void main(String[] args) &#123; MyThread myThread1=new MyThread(); MyThread myThread2=new MyThread(); Thread thread1=new Thread(myThread1); Thread thread2=new Thread(myThread2); thread1.start(); thread2.start(); &#125;&#125; 运行结果： 12Thread-1is running!Thread-0is running! 在传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，参考JDK源代码： 12345public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 3、实现Callable接口通过FutureTask包装器来创建Thread线程 和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法功能要强大。 call()方法可以有返回值 call()方法可以声明抛出异常 Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。 boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务 V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值 V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException boolean isDone()：若Callable任务完成，返回True boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True 介绍了相关的概念之后，创建并启动有返回值的线程的步骤如下： 1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。 2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值 3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口） 4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值 12345678910111213141516public class CallableDemo implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; return 5; &#125;&#125;public class MyThread&#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CallableDemo callable=new CallableDemo(); FutureTask&lt;Integer&gt;futureTask=new FutureTask&lt;Integer&gt;(callable); new Thread(futureTask).start(); Integer result=futureTask.get(); System.out.println(result); &#125;&#125; 结果： 15 1、FutrueTask类实现了RunnableFutrue接口，如下图 2、RunnableFutrue接口继承了Runnable和Futrue接口，如下图 由上图即可发现，FutrueTask类间接的实现了Runnable接口，从而可以使用new Thread(new FutrueTask(callable))去调用线程的start()方法启动线程。 3、继续进入Future接口中会发现get()方法 因此FutrueTask可以通过调用get()方法获取到返回的结果。用一张图来总结以上几个类和接口之间的关系，如下图： 4、使用ExecutorService、Callable、Future实现有返回结果的线程ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，有了这种特征就不需要再为了得到返回值而大费周折了。而且自己实现了也可能漏洞百出。 可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。 执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。 注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。 再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。 下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下： Test类： 123456789101112131415161718192021222324252627282930313233343536/** * 有返回值的线程 */@SuppressWarnings(\"unchecked\")public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(\"----程序开始运行----\"); Date date1 = new Date(); int taskSize = 5; // 创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(taskSize); // 创建多个有返回值的任务 List&lt;Future&gt; list = new ArrayList&lt;Future&gt;(); for (int i = 0; i &lt; taskSize; i++) &#123; Callable c = new MyCallable(i + \" \"); // 执行任务并获取Future对象 Future f = pool.submit(c); // System.out.println(\"&gt;&gt;&gt;\" + f.get().toString()); list.add(f); &#125; // 关闭线程池 pool.shutdown(); // 获取所有并发任务的运行结果 for (Future f : list) &#123; // 从Future对象上获取任务的返回值，并输出到控制台 System.out.println(\"&gt;&gt;&gt;\" + f.get().toString()); &#125; Date date2 = new Date(); System.out.println(\"----程序结束运行----，程序运行时间【\" + (date2.getTime() - date1.getTime()) + \"毫秒】\"); &#125;&#125; MyCallable类： 123456789101112131415161718class MyCallable implements Callable&lt;Object&gt; &#123; private String taskNum; MyCallable(String taskNum) &#123; this.taskNum = taskNum; &#125; @Override public Object call() throws Exception &#123; System.out.println(\"&gt;&gt;&gt;\" + taskNum + \"任务启动\"); Date dateTmp1 = new Date(); Thread.sleep(1000); Date dateTmp2 = new Date(); long time = dateTmp2.getTime() - dateTmp1.getTime(); System.out.println(\"&gt;&gt;&gt;\" + taskNum + \"任务终止\"); return taskNum + \"任务返回运行结果,当前任务时间【\" + time + \"毫秒】\"; &#125;&#125; 代码说明：上述代码中Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。public static ExecutorService newFixedThreadPool(int nThreads) 创建固定数目线程的线程池。public static ExecutorService newCachedThreadPool() 创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的Executor。public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。 线程之Callable、Future 和FutureTask使用及源码分析 java创建线程的四种方法（转） - 小白和熊猫 - 博客园 JAVA多线程实现的四种方式 具体使用请参考：https://www.cnblogs.com/felixzh/p/6036074.html但是这里对FutureTask结果返回没有说明，参考下篇 2、线程池的种类 四种。 查了网上的一些资料，上面都是先讲线程池存在的必要性：针对一些需要处理的短小而数量巨多的线程。比如在服务器中客户端浏览器的请求就有短小数量多的特点。 如果我们单纯地执行来一个请求回复一个，来回切换线程的代价太大。比如你要二十种不同的水果，他们分别放在相隔一米的管道里，并且每种水果发来的请求不一致，比如有的想要去皮，有的想要切盘，这时线程可以看作是“去皮”“切盘”前的准备工作，比如冲洗一下或者准备水果刀之类的。把线程准备好之后就可以进行最后的处理。 这时候，如果苹果说他想去皮，你要准备水果刀，再传过去给老大处理，二十米开外的菠萝说他想切块，你得准备螺丝刀，再给老大处理，是不是很麻烦，来回跑下来累得不行，还要准备不同的工具，效率太低。这时候就有了线程池的说法。线程池，每一个线程为一个要求服务，比如去皮，就创建去皮的线程，去核，就创建去核的线程（一般来说，某种水果对应的要求是一致的）。这里线程就是为去核，去皮做准备工作。这时候，就不用重复准备工作了。 四种线程池：https://www.cnblogs.com/aaron911/p/6213808.html https://blog.csdn.net/z_s_z2016/article/details/81674893?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task ———————————————— 版权声明：本文为CSDN博主「murongxian_1」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/murongxian_1/article/details/81109294","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://nimisora.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Synchronized底层实现原理","slug":"Java/Synchronized底层实现原理","date":"2020-03-07T02:42:10.000Z","updated":"2020-03-13T08:43:58.098Z","comments":true,"path":"post/305BPMG.html","link":"","permalink":"http://nimisora.com/post/305BPMG.html","excerpt":"","text":"synchronized的底层实现原理及各种优化synchronized概述synchronized，单词译为同步，是Java的内建锁，用来确保线程安全，是解决并发问题的一种重要手段。synchronized可以保证在多线程状态下，每次仅有一个线程访问共享资源。 synchronized的作用主要有以下三个： 原子性：线程互斥的访问同步代码块，可以将小原子合成大原子。可见性：synchronized解锁之前，必须将工作内存中的数据同步到主内存，其它线程操作该变量时每次都可以看到被修改后的值。有序性：一个线程的加锁，必须等到其它线程将锁释放；一个线程要释放锁，首先要加锁。synchronized同步原理synchronized仅是Java中的一个关键字，在使用的过程中并没有看到显示的加锁和解锁过程。因此有必要通过javap命令，查看相应的字节码文件。 synchronized修饰代码块 123456789101112131415public class Test implements Runnable &#123; @Override public void run() &#123; // 加锁操作 synchronized (this) &#123; System.out.println(\"hello\"); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); Thread thread = new Thread(test); thread.start(); &#125;&#125; javap查看相应的class文件： 可以看出在执行同步代码块之前之后都有一个monitor字样，其中前面的是monitorenter，后面的是离开monitorexit，不难想象一个线程也执行同步代码块，首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。 为什么会有两个monitorexit呢？ 这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。 synchronized修饰方法 123456789101112public class Test implements Runnable &#123; @Override public synchronized void run() &#123; System.out.println(\"hello again\"); &#125; public static void main(String[] args) &#123; Test test = new Test(); Thread thread = new Thread(test); thread.start(); &#125;&#125; 仅有ACC_SYNCHRONIZED这么一个标志，该标记表明线程进入该方法时，需要monitorenter，退出该方法时需要monitorexit。 synchronized可重入的原理重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。 锁优化JDK1.6之前，synchronized是一个重量级锁，何谓重量级锁？就是多个线程竞争同一把锁，未获得锁的线程都会被阻塞，等到持有锁的线程将锁释放之后，这些线程又被唤醒。其中线程的阻塞和唤醒都与操作系统有关，是一个极其耗费CPU资源的过程。因此为了提高synchronized的性能特地在JDK1.6做了优化。据说在JDK1.4已经优化完成，不过默认是关闭状态。 在了解锁优化之前需要先了解一些概念：Java对象内存模型 一个Java对象由，对象标记，类型指针，真实数据，内存对齐四部分组成。 对象标记也称Mark Word字段，存储当前对象的一些运行时数据。类型指针，JVM根据该指针确定该对象是哪个类的实例化对象。真实数据自然是对象的属性值。内存补齐，是当数据不是对齐数的整数倍的时候，进行调整，使得对象的整体大小是对齐数的整数倍方便寻址。典型的以空间换时间的思想。其中对象标记和类型指针统称为Java对象头。 Mark Word字段Mark Word用于存储对象自身运行时的数据，如hashcode，GC分代年龄，锁状态标志位，线程持有的锁，偏向线程ID，等等。 为社么Java的任意对象都可以作为锁？在Java对象头中，存在一个monitor对象，每个对象自创建之后在对象头中就含有monitor对象，monitor是线程私有的，不同的对象monitor自然也是不同的，因此对象作为锁的本质是对象头中的monitor对象作为了锁。这便是为什么Java的任意对象都可以作为锁的原因。 优化手段偏向锁：偏向锁针对的是锁不存在竞争，每次仅有一个线程来获取该锁，为了提高获取锁的效率，因此将该锁偏向该线程。提升性能。 偏向锁的获取： 1.首先检测是否为可偏向状态（锁标识是否设置成1，锁标志位是否为01）.2.如果处于可偏向状态，测试Mark Word中的线程ID是否指向自己，如果是，不需要再次获取锁，直接执行同步代码。3.如果线程Id，不是自己的线程Id，通过CAS获取锁，获取成功表明当前偏向锁不存在竞争，获取失败，则说明当前偏向锁存在锁竞争，偏向锁膨胀为轻量级锁。 偏向锁的撤销： 偏向锁只有当出现竞争时，才会出现锁撤销。 1。等待一个全局安全点，此时所有的线程都是暂停的，检查持有锁的线程状态，如果能找到说明当前线程还存活，说明还在执行同步块中的代码，首相将该线程阻塞，然后进行锁升级，升级到轻量级锁，唤醒该线程继续执行代同步码。2.如果持有偏向锁的线程未存活，将对象头中的线程置null，然后直接锁升级。 轻量级锁：偏向锁考虑的是不存在多个线程竞争同一把锁，而轻量级锁考虑的是，多个线程不会在同一时刻来竞争同一把锁。 轻量级锁的获取： 1.在线程的栈帧中创建用于存储锁记录得空间，2.并将Mark Word复制到锁记录中，（这一步不论是否存在竞争都可以执行）。3.尝试使用CAS将对象头中得Mark word字段变成指向锁记录得指针。4 操作成功，不存在锁竞争，执行同步代码。5操作失败，锁已经被其它线程抢占了，这时轻量级锁膨胀为重量级锁。 轻量级锁的释放： 反替换，使用CAS将栈帧中得锁录空间替换到对象头，成功没有锁竞争，锁得以释放，失败说明存在竞争，那块指向锁记录得指针有别的线程在用，因此锁膨胀升级为重量级锁。 重量级锁：重量级锁描述同一时刻有多个线程竞争同一把锁。 当多个线程共同竞争同一把锁时，竞争失败得锁会被阻塞，等到持有锁的线程将锁释放后再次唤醒阻塞的线程，因为线程的唤醒和阻塞是一个很耗费CPU资源的操作，因此此处采取自适应自旋来获取重量级锁来获取重量级锁。 锁的升级无锁 – &gt; 偏向锁 —–&gt; 轻量级锁 —- &gt; 重量级锁 其它优化自旋锁：线程未获得锁后，不是一昧的阻塞，而是让线程不断尝试获取锁。 缺点：若线程占用锁时间过长，导致CPU资源白白浪费。 解决方式：当尝试次数达到每个值得时候，线程挂起。 自适应自旋锁：自旋得次数由上一次获取锁的自旋次数决定，次数稍微延长一点点。 锁消除对于线程的私有变量，不存在并发问题，没有必要加锁，即使加锁编译后，也会去掉。 锁粗化当一个循环中存在加锁操作时，可以将加锁操作提到循环外面执行，一次加锁代替多次加锁，提升性能。————————————————版权声明：本文为CSDN博主「你的酒窝里有酒」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43213517/article/details/89713899","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"}],"tags":[{"name":"Synchronized","slug":"Synchronized","permalink":"http://nimisora.com/tags/Synchronized/"}]},{"title":"Collections知识点整理","slug":"Java/Collections知识点整理","date":"2020-03-05T08:12:10.000Z","updated":"2020-03-13T08:55:19.032Z","comments":true,"path":"post/1GGZHEY.html","link":"","permalink":"http://nimisora.com/post/1GGZHEY.html","excerpt":"","text":"Arraylist 与 LinkedList 区别? 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！） 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(\bE e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 补充内容:RandomAccess接口","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"}],"tags":[{"name":"Collections","slug":"Collections","permalink":"http://nimisora.com/tags/Collections/"}]},{"title":"深入理解Volatile关键字及其实现原理","slug":"Java/深入理解Volatile关键字及其实现原理","date":"2020-03-05T02:13:29.000Z","updated":"2020-03-13T08:44:13.845Z","comments":true,"path":"post/1XVQCVA.html","link":"","permalink":"http://nimisora.com/post/1XVQCVA.html","excerpt":"","text":"volatile的用法转载自：https://blog.csdn.net/zezezuiaiya/article/details/81456060 volatile通常被比喻成”轻量级的synchronized”，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。 volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。 如以下代码，是一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰可能被多个线程同时访问到的singleton。 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; volatile的原理为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。 但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。 但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议 缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。 volatile与可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。 前面的关于volatile的原理中介绍过了，Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。 volatile与有序性有序性即程序执行的顺序按照代码的先后顺序执行。 除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。 而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。 普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。 volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-&gt;add-&gt;save 的执行顺序就是：load、add、save。 volatile与原子性原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。 为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。 所以，volatile是不能保证原子性的。 在以下两个场景中可以使用volatile来代替synchronized： 1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。 2、变量不需要与其他状态变量共同参与不变约束。 除以上场景外，都需要使用其他方式来保证原子性，如synchronized或者concurrent包。 我们来看一下volatile和原子性的例子： 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 以上代码比较简单，就是创建10个线程，然后分别执行1000次i++操作。正常情况下，程序的输出结果应该是10000，但是，多次执行的结果都小于10000。这其实就是volatile无法满足原子性的原因。 为什么会出现这种情况呢，那就是因为虽然volatile可以保证inc在多个线程之间的可见性。但是无法inc++的原子性。 总结与思考我们介绍过了volatile关键字和synchronized关键字。现在我们知道，synchronized可以保证原子性、有序性和可见性。而volatile却只能保证有序性和可见性。 -————————————————————————————————————————- 前言 我们知道volatile关键字的作用是保证变量在多线程之间的可见性，它是java.util.concurrent包的核心，没有volatile就没有这么多的并发类给我们使用。 本文详细解读一下volatile关键字如何保证变量在多线程之间的可见性，在此之前，有必要讲解一下CPU缓存的相关知识，掌握这部分知识一定会让我们更好地理解volatile的原理，从而更好、更正确地地使用volatile关键字。 CPU缓存 CPU缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快得多，举个例子： 一次主内存的访问通常在几十到几百个时钟周期 一次L1高速缓存的读写只需要1~2个时钟周期 一次L2高速缓存的读写也只需要数十个时钟周期 这种访问速度的显著差异，导致CPU可能会花费很长时间等待数据到来或把数据写入内存。 基于此，现在CPU大多数情况下读写都不会直接访问内存（CPU都没有连接到内存的管脚），取而代之的是CPU缓存，CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。 按照读取顺序与CPU结合的紧密程度，CPU缓存可分为： 一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存 二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半 三级缓存：简称L3 Cache，部分高端CPU才有 每一级缓存中所存储的数据全部都是下一级缓存中的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也相对递增。 当CPU要读取一个数据时，首先从一级缓存中查找，如果没有再从二级缓存中查找，如果还是没有再从三级缓存中或内存中查找。一般来说每级缓存的命中率大概都有80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。 使用CPU缓存带来的问题 用一张图表示一下CPU–&gt;CPU缓存–&gt;主内存数据读取之间的关系： 当系统运行时，CPU执行计算的过程如下： 程序以及数据被加载到主内存 指令和数据被加载到CPU缓存 CPU执行指令，把结果写到高速缓存 高速缓存中的数据写回主内存 如果服务器是单核CPU，那么这些步骤不会有任何的问题，但是如果服务器是多核CPU，那么问题来了，以Intel Core i7处理器的高速缓存概念模型为例（图片摘自《深入理解计算机系统》）： 试想下面一种情况： 核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存 核3做了上面同样的工作，这样核0与核3的缓存拥有同样的数据 核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存 核3访问该字节，由于核0并未将数据写回主存，数据不同步 为了解决这个问题，CPU制造商制定了一个规则：当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效。于是，在上面的情况下，核3发现自己的缓存中数据已无效，核0将立即把自己的数据写回主存，然后核3重新读取该数据。 反汇编Java字节码，查看汇编层面对volatile关键字做了什么 有了上面的理论基础，我们可以研究volatile关键字到底是如何实现的。首先写一段简单的代码： 1234567891011121314151617181920 1 /** 2 * @author 五月的仓颉http://www.cnblogs.com/xrq730/p/7048693.html 3 */ 4 public class LazySingleton &#123; 5 6 private static volatile LazySingleton instance = null; 7 8 public static LazySingleton getInstance() &#123; 9 if (instance == null) &#123;10 instance = new LazySingleton();11 &#125;12 13 return instance;14 &#125;15 16 public static void main(String[] args) &#123;17 LazySingleton.getInstance();18 &#125;19 20 &#125; 首先反编译一下这段代码的.class文件，看一下生成的字节码： 没有任何特别的。要知道，字节码指令，比如上图的getstatic、ifnonnull、new等，最终对应到操作系统的层面，都是转换为一条一条指令去执行，我们使用的PC机、应用服务器的CPU架构通常都是IA-32架构的，这种架构采用的指令集是CISC（复杂指令集），而汇编语言则是这种指令集的助记符。 因此，既然在字节码层面我们看不出什么端倪，那下面就看看将代码转换为汇编指令能看出什么端倪。Windows上要看到以上代码对应的汇编码不难（吐槽一句，说说不难，为了这个问题我找遍了各种资料，差点就准备安装虚拟机，在Linux系统上搞了），访问hsdis工具路径可直接下载hsdis工具，下载完毕之后解压，将hsdis-amd64.dll与hsdis-amd64.lib两个文件放在%JAVA_HOME%\\jre\\bin\\server路径下即可，如下图： 然后跑main函数，跑main函数之前，加入如下虚拟机参数： 1-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*LazySingleton.getInstance 运行main函数即可，代码生成的汇编指令为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 1 Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output 2 CompilerOracle: compileonly *LazySingleton.getInstance 3 Loaded disassembler from D:\\JDK\\jre\\bin\\server\\hsdis-amd64.dll 4 Decoding compiled method 0x0000000002931150: 5 Code: 6 Argument 0 is unknown.RIP: 0x29312a0 Code size: 0x00000108 7 [Disassembling for mach='amd64'] 8 [Entry Point] 9 [Verified Entry Point]10 [Constants]11 # &#123;method&#125; 'getInstance' '()Lorg/xrq/test/design/singleton/LazySingleton;' in 'org/xrq/test/design/singleton/LazySingleton'12 # [sp+0x20] (sp of caller)13 0x00000000029312a0: mov dword ptr [rsp+0ffffffffffffa000h],eax14 0x00000000029312a7: push rbp15 0x00000000029312a8: sub rsp,10h ;*synchronization entry16 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@-1 (line 13)17 0x00000000029312ac: mov r10,7ada9e428h ; &#123;oop(a 'java/lang/Class' = 'org/xrq/test/design/singleton/LazySingleton')&#125;18 0x00000000029312b6: mov r11d,dword ptr [r10+58h]19 ;*getstatic instance20 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@0 (line 13)21 0x00000000029312ba: test r11d,r11d22 0x00000000029312bd: je 29312e0h23 0x00000000029312bf: mov r10,7ada9e428h ; &#123;oop(a 'java/lang/Class' = 'org/xrq/test/design/singleton/LazySingleton')&#125;24 0x00000000029312c9: mov r11d,dword ptr [r10+58h]25 0x00000000029312cd: mov rax,r1126 0x00000000029312d0: shl rax,3h ;*getstatic instance27 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@16 (line 17)28 0x00000000029312d4: add rsp,10h29 0x00000000029312d8: pop rbp30 0x00000000029312d9: test dword ptr [330000h],eax ; &#123;poll_return&#125;31 0x00000000029312df: ret32 0x00000000029312e0: mov rax,qword ptr [r15+60h]33 0x00000000029312e4: mov r10,rax34 0x00000000029312e7: add r10,10h35 0x00000000029312eb: cmp r10,qword ptr [r15+70h]36 0x00000000029312ef: jnb 293135bh37 0x00000000029312f1: mov qword ptr [r15+60h],r1038 0x00000000029312f5: prefetchnta byte ptr [r10+0c0h]39 0x00000000029312fd: mov r11d,0e07d00b2h ; &#123;oop('org/xrq/test/design/singleton/LazySingleton')&#125;40 0x0000000002931303: mov r10,qword ptr [r12+r11*8+0b0h]41 0x000000000293130b: mov qword ptr [rax],r1042 0x000000000293130e: mov dword ptr [rax+8h],0e07d00b2h43 ; &#123;oop('org/xrq/test/design/singleton/LazySingleton')&#125;44 0x0000000002931315: mov dword ptr [rax+0ch],r12d45 0x0000000002931319: mov rbp,rax ;*new ; - org.xrq.test.design.singleton.LazySingleton::getInstance@6 (line 14)46 0x000000000293131c: mov rdx,rbp47 0x000000000293131f: call 2907c60h ; OopMap&#123;rbp=Oop off=132&#125;48 ;*invokespecial &lt;init&gt;49 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@10 (line 14)50 ; &#123;optimized virtual_call&#125;51 0x0000000002931324: mov r10,rbp52 0x0000000002931327: shr r10,3h53 0x000000000293132b: mov r11,7ada9e428h ; &#123;oop(a 'java/lang/Class' = 'org/xrq/test/design/singleton/LazySingleton')&#125;54 0x0000000002931335: mov dword ptr [r11+58h],r10d55 0x0000000002931339: mov r10,7ada9e428h ; &#123;oop(a 'java/lang/Class' = 'org/xrq/test/design/singleton/LazySingleton')&#125;56 0x0000000002931343: shr r10,9h57 0x0000000002931347: mov r11d,20b2000h58 0x000000000293134d: mov byte ptr [r11+r10],r12l59 0x0000000002931351: lock add dword ptr [rsp],0h ;*putstatic instance60 ; - org.xrq.test.design.singleton.LazySingleton::getInstance@13 (line 14)61 0x0000000002931356: jmp 29312bfh62 0x000000000293135b: mov rdx,703e80590h ; &#123;oop('org/xrq/test/design/singleton/LazySingleton')&#125;63 0x0000000002931365: nop64 0x0000000002931367: call 292fbe0h ; OopMap&#123;off=204&#125;65 ;*new ; - org.xrq.test.design.singleton.LazySingleton::getInstance@6 (line 14)66 ; &#123;runtime_call&#125;67 0x000000000293136c: jmp 2931319h68 0x000000000293136e: mov rdx,rax69 0x0000000002931371: jmp 2931376h70 0x0000000002931373: mov rdx,rax ;*new ; - org.xrq.test.design.singleton.LazySingleton::getInstance@6 (line 14)71 0x0000000002931376: add rsp,10h72 0x000000000293137a: pop rbp73 0x000000000293137b: jmp 2932b20h ; &#123;runtime_call&#125;74 [Stub Code]75 0x0000000002931380: mov rbx,0h ; &#123;no_reloc&#125;76 0x000000000293138a: jmp 293138ah ; &#123;runtime_call&#125;77 [Exception Handler]78 0x000000000293138f: jmp 292fca0h ; &#123;runtime_call&#125;79 [Deopt Handler Code]80 0x0000000002931394: call 2931399h81 0x0000000002931399: sub qword ptr [rsp],5h82 0x000000000293139e: jmp 2909000h ; &#123;runtime_call&#125;83 0x00000000029313a3: hlt84 0x00000000029313a4: hlt85 0x00000000029313a5: hlt86 0x00000000029313a6: hlt87 0x00000000029313a7: hlt 这么长长的汇编代码，可能大家不知道CPU在哪里做了手脚，没事不难，定位到59、60两行： 120x0000000002931351: lock add dword ptr [rsp],0h ;*putstatic instance ; - org.xrq.test.design.singleton.LazySingleton::getInstance@13 (line 14) 之所以定位到这两行是因为这里结尾写明了line 14，line 14即volatile变量instance赋值的地方。后面的add dword ptr [rsp],0h都是正常的汇编语句，意思是将双字节的栈指针寄存器+0，这里的关键就是add前面的lock指令，后面详细分析一下lock指令的作用和为什么加上lock指令后就能保证volatile关键字的内存可见性。 lock指令做了什么 之前有说过IA-32架构，关于CPU架构的问题大家有兴趣的可以自己查询一下，这里查询一下IA-32手册关于lock指令的描述，没有IA-32手册的可以去这个地址下载IA-32手册下载地址，是个中文版本的手册。 我摘抄一下IA-32手册中关于lock指令作用的一些描述（因为lock指令的作用在手册中散落在各处，并不是在某一章或者某一节专门讲）： 12345678910111213141516在修改内存操作时，使用LOCK前缀去调用加锁的读-修改-写操作，这种机制用于多处理器系统中处理器之间进行可靠的通讯，具体描述如下：（1）在Pentium和早期的IA-32处理器中，LOCK前缀会使处理器执行当前指令时产生一个LOCK#信号，这种总是引起显式总线锁定出现（2）在Pentium4、Inter Xeon和P6系列处理器中，加锁操作是由高速缓存锁或总线锁来处理。如果内存访问有高速缓存且只影响一个单独的高速缓存行，那么操作中就会调用高速缓存锁，而系统总线和系统内存中的实际区域内不会被锁定。同时，这条总线上的其它Pentium4、Intel Xeon或者P6系列处理器就回写所有已修改的数据并使它们的高速缓存失效，以保证系统内存的一致性。如果内存访问没有高速缓存且/或它跨越了高速缓存行的边界，那么这个处理器就会产生LOCK#信号，并在锁定操作期间不会响应总线控制请求32位IA-32处理器支持对系统内存中的某个区域进行加锁的原子操作。这些操作常用来管理共享的数据结构（如信号量、段描述符、系统段或页表），两个或多个处理器可能同时会修改这些数据结构中的同一数据域或标志。处理器使用三个相互依赖的机制来实现加锁的原子操作：1、保证原子操作2、总线加锁，使用LOCK#信号和LOCK指令前缀3、高速缓存相干性协议，确保对高速缓存中的数据结构执行原子操作（高速缓存锁）。这种机制存在于Pentium4、Intel Xeon和P6系列处理器中IA-32处理器提供有一个LOCK#信号，会在某些关键内存操作期间被自动激活，去锁定系统总线。当这个输出信号发出的时候，来自其他处理器或总线代理的控制请求将被阻塞。软件能够通过预先在指令前添加LOCK前缀来指定需要LOCK语义的其它场合。在Intel386、Intel486、Pentium处理器中，明确地对指令加锁会导致LOCK#信号的产生。由硬件设计人员来保证系统硬件中LOCK#信号的可用性，以控制处理器间的内存访问。对于Pentinum4、Intel Xeon以及P6系列处理器，如果被访问的内存区域是在处理器内部进行高速缓存的，那么通常不发出LOCK#信号；相反，加锁只应用于处理器的高速缓存。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253为显式地强制执行LOCK语义，软件可以在下列指令修改内存区域时使用LOCK前缀。当LOCK前缀被置于其它指令之前或者指令没有对内存进行写操作（也就是说目标操作数在寄存器中）时，会产生一个非法操作码异常（#UD）。【1】位测试和修改指令（BTS、BTR、BTC）【2】交换指令（XADD、CMPXCHG、CMPXCHG8B）【3】自动假设有LOCK前缀的XCHG指令【4】下列单操作数的算数和逻辑指令：INC、DEC、NOT、NEG【5】下列双操作数的算数和逻辑指令：ADD、ADC、SUB、SBB、AND、OR、XOR一个加锁的指令会保证对目标操作数所在的内存区域加锁，但是系统可能会将锁定区域解释得稍大一些。软件应该使用相同的地址和操作数长度来访问信号量（用作处理器之间发送信号的共享内存）。例如，如果一个处理器使用一个字来访问信号量，其它处理器就不应该使用一个字节来访问这个信号量。总线锁的完整性不收内存区域对齐的影响。加锁语义会一直持续，以满足更新整个操作数所需的总线周期个数。但是，建议加锁访问应该对齐在它们的自然边界上，以提升系统性能：【1】任何8位访问的边界（加锁或不加锁）【2】锁定的字访问的16位边界【3】锁定的双字访问的32位边界【4】锁定的四字访问的64位边界对所有其它的内存操作和所有可见的外部事件来说，加锁的操作都是原子的。所有取指令和页表操作能够越过加锁的指令。加锁的指令可用于同步一个处理器写数据而另一个处理器读数据的操作。 123456789101112131415161718192021IA-32架构提供了几种机制用来强化或弱化内存排序模型，以处理特殊的编程情形。这些机制包括：【1】I/O指令、加锁指令、LOCK前缀以及串行化指令等，强制在处理器上进行较强的排序【2】SFENCE指令（在Pentium III中引入）和LFENCE指令、MFENCE指令（在Pentium4和Intel Xeon处理器中引入）提供了某些特殊类型内存操作的排序和串行化功能...（这里还有两条就不写了）这些机制可以通过下面的方式使用。总线上的内存映射设备和其它I/O设备通常对向它们缓冲区写操作的顺序很敏感，I/O指令（IN指令和OUT指令）以下面的方式对这种访问执行强写操作的排序。在执行了一条I/O指令之前，处理器等待之前的所有指令执行完毕以及所有的缓冲区都被都被写入了内存。只有取指令和页表查询能够越过I/O指令，后续指令要等到I/O指令执行完毕才开始执行。 反复思考IA-32手册对lock指令作用的这几段描述，可以得出lock指令的几个作用： 锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存 lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据 不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序（1）中写了由于效率问题，实际后来的处理器都采用锁缓存来替代锁总线，这种场景下多缓存的数据一致是通过缓存一致性协议来保证的，我们来看一下什么是缓存一致性协议。 缓存一致性协议 讲缓存一致性之前，先说一下缓存行的概念： 缓存是分段（line）的，一个段对应一块存储空间，我们称之为缓存行，它是CPU缓存中可分配的最小存储单元，大小32字节、64字节、128字节不等，这与CPU架构有关，通常来说是64字节。当CPU看到一条读取内存的指令时，它会把内存地址传递给一级数据缓存，一级数据缓存会检查它是否有这个内存地址对应的缓存段，如果没有就把整个缓存段从内存（或更高一级的缓存）中加载进来。注意，这里说的是一次加载整个缓存段，这就是上面提过的局部性原理 上面说了，LOCK#会锁总线，实际上这不现实，因为锁总线效率太低了。因此最好能做到：使用多组缓存，但是它们的行为看起来只有一组缓存那样。缓存一致性协议就是为了做到这一点而设计的，就像名称所暗示的那样，这类协议就是要使多组缓存的内容保持一致。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于”嗅探（snooping）”协议，它的基本思想是： 12所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个CPU缓存可以读写内存）。CPU缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其它处理器马上知道这块内存在它们的缓存段中已失效。 MESI协议是当前最主流的缓存一致性协议，在MESI协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是： 这里的I、S和M状态已经有了对应的概念：失效/未载入、干净以及脏的缓存段。所以这里新的知识点只有E状态，代表独占式访问，这个状态解决了”在我们开始修改某块内存之前，我们需要告诉其它处理器”这一问题：只有当缓存行处于E或者M状态时，处理器才能去写它，也就是说只有在这两种状态下，处理器是独占这个缓存行的。当处理器想写某个缓存行时，如果它没有独占权，它必须先发送一条”我要独占权”的请求给总线，这会通知其它处理器把它们拥有的同一缓存段的拷贝失效（如果有）。只有在获得独占权后，处理器才能开始修改数据—-并且此时这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。 反之，如果有其它处理器想读取这个缓存行（马上能知道，因为一直在嗅探总线），独占或已修改的缓存行必须先回到”共享”状态。如果是已修改的缓存行，那么还要先把内容回写到内存中。 由lock指令回看volatile变量读写 相信有了上面对于lock的解释，volatile关键字的实现原理应该是一目了然了。首先看一张图： 工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。 那么当写两条线程Thread-A与Threab-B同时操作主存中的一个volatile变量i时，Thread-A写了变量i，那么： Thread-A发出LOCK#指令 发出的LOCK#指令锁总线（或锁缓存行），同时让Thread-B高速缓存中的缓存行内容失效 Thread-A向主存回写最新修改的i Thread-B读取变量i，那么： Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值 由此可以看出，volatile关键字的读和普通变量的读取相比基本没差别，差别主要还是在变量的写操作上。","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"}],"tags":[]},{"title":"Redis缓存穿透、缓存雪崩、redis并发问题分析","slug":"数据库/Redis缓存穿透、缓存雪崩、redis并发问题分析","date":"2020-03-02T10:34:38.000Z","updated":"2020-03-13T08:44:19.603Z","comments":true,"path":"post/177SER2.html","link":"","permalink":"http://nimisora.com/post/177SER2.html","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"Java中的四个访问修饰符范围","slug":"Java/Java中的四个访问修饰符范围","date":"2020-03-02T10:22:55.000Z","updated":"2020-03-13T08:43:38.482Z","comments":true,"path":"post/3R9V3YG.html","link":"","permalink":"http://nimisora.com/post/3R9V3YG.html","excerpt":"","text":"同一个类 同一个包 不同包的子类 不同包的非子类 Private √ Default √ √ Protected √ √ √ Public √ √ √ √ public：Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不 仅可以跨类访问，而且允许跨包（package）访问。private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以 及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、 属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访 问。","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"},{"name":"Java","slug":"Java/Java","permalink":"http://nimisora.com/categories/Java/Java/"}],"tags":[]},{"title":"常见用例测试","slug":"测试/常见用例测试","date":"2020-03-02T07:54:48.000Z","updated":"2020-03-12T01:13:55.271Z","comments":true,"path":"post/4NV85Z.html","link":"","permalink":"http://nimisora.com/post/4NV85Z.html","excerpt":"","text":"1. 如何对一瓶矿泉水瓶进行测试 根据功能、性能、界面、可靠性、易用性、兼容性、安全性测试方面进行测试，具有条理性。 功能： 测试矿泉水瓶的容量是多少，是否与标注相同 水瓶本身漏不漏水 水瓶中的水是否能够全部倒出来，还是会在瓶中残留一些 水瓶拧紧水漏不漏 性能： 水瓶里装满水，倒立观察 24 小时，是否漏水 水瓶盖能够使用多少次，随着次数的增多，螺纹是否会变松 界面： 水瓶上的说明是否清楚，什么材质做的，容量是多少 水瓶上的字体是否容易被抹去 可靠性： 水瓶从高处下落会对瓶子本身造成影响 兼容性： 水瓶中装其他液体，如酒精、油等是否泄漏，是否与瓶子本身反应 安全性： 水瓶装满水在高温或者低温下，是否会因为气压不同而喷开 水瓶装满水放在冰箱中冷冻是否会裂开 2. 如何测试共享单车从扫码到开锁这一环节 功能： 测试点开扫码界面，是否能够打开相机进行二维码扫描 测试扫码状态下，手电筒是否能够使用，是否能够转到输入车辆编码模式下 测试扫描界面是否能够识别二维码 测试扫描界面是否能够识别出单车是否属于本公司 测试扫码后，是否能够根据二维码查出车辆是否有问题 测试扫描后，车辆是否能够开锁成功 性能： 多长时间内能够识别出二维码 多长时间内二维码识别后能够解锁车辆成功 车锁会不会只开一半，什么情况下会这样 界面： 开锁成功后，App 界面是否会显示开锁成功 开锁失败后，App 界面是否会显示失败原因 可靠性： 车辆被扫码 N 次后，故障率是否提高 手机扫码端扫码 N 次后，不成功率是否提高 二维码上有灰尘，不清楚，是否能够扫码成功 兼容性： 不同手机型号进行扫码，是否都能成功 不同 App 版本扫码是否都能成功 不同小程序扫码是否能够成功 安全性： 车辆是否会被其他公司程序扫码成功 车辆没有开锁被移动是否会发出警告","categories":[{"name":"测试","slug":"测试","permalink":"http://nimisora.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"水","slug":"水","permalink":"http://nimisora.com/tags/%E6%B0%B4/"},{"name":"共享单车","slug":"共享单车","permalink":"http://nimisora.com/tags/%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6/"}]},{"title":"设计模式六大原则","slug":"设计模式/设计模式六大原则","date":"2020-03-02T07:27:14.000Z","updated":"2020-03-13T08:47:29.254Z","comments":true,"path":"post/2BCTX0P.html","link":"","permalink":"http://nimisora.com/post/2BCTX0P.html","excerpt":"","text":"https://www.cnblogs.com/dolphin0520/p/3919839.html 单一职责原则SRP(Single Responsibility Principle) 一个类只负责一个功能领域的相应职责，即就一个类而言，应该只有一个引起它变化的原因。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 开闭原则OCP(Open-Closed Principle) 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。 里氏替换原则LSP(Liskov Substitution Principle) 所有引用父类的地方必须能透明地使用其子类的对象。 里氏替换原则告诉我们：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，它不一定能够使用基类对象。 里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在使用里氏替换原则时需要注意如下几个问题： 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类类进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 运用里氏替换原则时，尽量把父类设计为抽象类或接口，让子类继承父类或实现父接口，并实现在父类中的声明的方法，运行时，子类实例替换父类实例，方便扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过一个新的子类来实现。 Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏替换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。 依赖倒置原则DIP(Dependency Inversion Principle) 抽象不应该依赖于细节，细节应当依赖于抽象，要针对接口编程，而不是针对实现编程。 依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口或抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒置原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入（当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。）的方式注入到其他对象中。 接口隔离原则ISP(Interface Segregation Principle) 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。 这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。 对于这两种不同的含义，ISP的表达方式以及含义都有所不同： 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 如果理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来并不方便，为了使接口的职责单一，需要将大借口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为”定制服务“，即为不同的客户端提供宽窄不同的接口。 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。 迪米特法则LoD(Law of Demeter) 一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 迪米特法则还有几种定义形式，包括：不要和”陌生人“说话，只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括一下几类： 当前对象本身 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友“，否则就是”陌生人“。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与”陌生人“发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用，即通过引入一个合理的第三者来降低现有对象之间的耦合度。 在将迪米特法则运用到系统设计中时，要注意下面几点： 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。 在类的设计上，只要有可能，一个类型应当设计成不变类。 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式/设计模式","permalink":"http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"面试考点回答","slug":"面试考点回答","date":"2020-03-01T15:27:39.000Z","updated":"2020-03-01T15:27:39.440Z","comments":true,"path":"post/12007PQ.html","link":"","permalink":"http://nimisora.com/post/12007PQ.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"URL去重","slug":"项目/URL去重","date":"2020-03-01T14:40:07.000Z","updated":"2020-03-13T08:41:42.745Z","comments":true,"path":"post/24V1B26.html","link":"","permalink":"http://nimisora.com/post/24V1B26.html","excerpt":"","text":"网络爬虫之网页URL去重的5种方法详解对网络爬虫有一定了解的小伙伴们应该都知道，网络爬虫在爬取信息的时候，为了避免爬虫爬到重复数据、爬虫陷入死循环等问题，我们就需要对URL去重。 目录 1、什么是URL去重？字面意思，去除相同的URL，使得爬虫在爬取过程中尽可能少的爬取重复数据。 2、为什么要进行URL去重？反过来说，就是不对URL进行去重，会产生那些问题呢？ 1、数据重复爬取2、爬虫陷入死循环3、爬取效率低下…..上面的问题是怎么产生的呢？ 首先，我们要明确一点，URL去重是应用于网络爬虫（不知道什么是网络爬虫自己度娘一下）的。 2.1、先了解爬虫的基本框架：单机版 (这里的单机版指的是一台机器)： 单机版中URL去重体现在： 爬取每一个页面前，先看看以前是否已经爬取过这个页面，如果没有爬取过就爬取，否则直接跳过。 分布式： 分布式爬虫中URL去重体现在：维护一个不重复的请求队列。 2.2、URL为什么会重复，爬虫又为什么会陷入死循环？这里以3个url为例：一个页面中会包括多个超链接，而所有的超链接都是我们可能要爬取的目标。 我们假设url1中有url2的超链接，url2有url3的超链接，url3又有url1的超链接，那么这三个页面就可以构成下面的关系。 相信聪明的你已经看出了端倪，如果再多几个页面，那么这些页面就形成了一个网（有回路），这是网络爬虫不对url去重而会陷入死循环的原因。 所以，要想编写出功能强大的网络爬虫，url去重是必不可少的。 3、URL去重的5种方式3.1、列表 列表优点：简单易操作 缺点：每次添加URL到列表之前，都要先查询一下是否已存在，非常耗费时间和内存空间。 3.2、set集合 集合优点：对比list来说，省去了过多的查询，节省了一些时间和内存空间 缺点：耗费内存空间较大，如果有一亿条URL，一个URL50字符： 100000000 * 50字符 * 2byte / 1024 / 1024 / 1024 约= 9.3GB 3.3、set+md5 优点：对比单纯使用set来说，md5加密方式大大缩小了占用内存空间 缺点：耗费内存空间还是很大，如果有一亿条URL，一个URL16字节： 100000000 * 16byte / 1024 / 1024 / 1024 约= 1.4GB 3.4、bitmap（位图）优点：对比使用set+md5来说，位图的方式将空间占用缩小到了极限。如果有一亿条URL，一个URL1位： 100000000 / 8bit / 1024 / 1024 / 1024 约= 12M 缺点：产生哈希冲突的可能性很大。 3.5、boomfilter(布隆过滤器) 优点：对比使用bitmap来说，BloomFilter降低了的哈希冲突的出现率。 缺点：对比bitmap方式来说，BloomFilter较多的耗费内存空间，有一定的误识别率和删除困难。 不存在漏报（False Negative），即某个元素在某个集合中，肯定能报出来。 可能存在误报（False Positive），即某个元素不在某个集合中，可能也被爆出来。 总结一下： 1、list : 简单易操作，耗费内存空间多，耗费资源多 2、set：比list耗费资源少 3、set+md5：比set耗费内存空间少（scrapy-redis中使用的就是类似这种的） 4、bitmap： 耗费内存空间最少，产生hash冲突的概率极大。 5、boomfilter: 耗费内存空间比bitmap多一点，产生hash冲突的概率比bitmap小一些，但是可能存在误报，而且删除困难。 最后多说一点：去重是一种思想，去重并不是只能用在url上，还可以用在任何东西上。比如说：爬取100万首音乐，就可以用去重来保证爬取到的音乐的内容不重复。 ————————————————版权声明：本文为CSDN博主「稳步前进的程序猿^_^」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_42425970/article/details/102532185","categories":[{"name":"项目","slug":"项目","permalink":"http://nimisora.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"项目","slug":"项目/项目","permalink":"http://nimisora.com/categories/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"URL","slug":"URL","permalink":"http://nimisora.com/tags/URL/"}]},{"title":"mybatis预防sql注入","slug":"数据库/mybatis预防sql注入","date":"2020-03-01T14:21:35.000Z","updated":"2020-03-13T08:46:55.542Z","comments":true,"path":"post/34W4F6V.html","link":"","permalink":"http://nimisora.com/post/34W4F6V.html","excerpt":"","text":"https://www.cnblogs.com/jokmangood/p/11705850.html 1、首先看一下下面两个sql语句的区别：12345678910111213&lt;select id=\"selectByNameAndPassword\" parameterType=\"java.util.Map\" resultMap=\"BaseResultMap\"&gt;select id, username, password, rolefrom userwhere username = #&#123;username,jdbcType=VARCHAR&#125;and password = #&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt;&lt;select id=\"selectByNameAndPassword\" parameterType=\"java.util.Map\" resultMap=\"BaseResultMap\"&gt;select id, username, password, rolefrom userwhere username = $&#123;username,jdbcType=VARCHAR&#125;and password = $&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt; mybatis中的#和$的区别： 1、#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。 如：where username=#{username}，如果传入的值是111,那么解析成sql时的值为where username=”111”, 如果传入的值是id，则解析成的sql为where username=”id”. 2、$将传入的数据直接显示生成在sql中。 如：where username=${username}，如果传入的值是111,那么解析成sql时的值为where username=111； 如果传入的值是;drop table user;，则解析成的sql为：select id, username, password, role from user where username=;drop table user; 3、#方式能够很大程度防止sql注入，$方式无法防止Sql注入。 4、$方式一般用于传入数据库对象，例如传入表名. 5、一般能用#的就别用$，若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止sql注入攻击。 6、在MyBatis中，“${xxx}”这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式。所以，这样的参数需要我们在代码中手工进行处理来防止注入。 【结论】在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。 2、什么是sql注入sql注入解释：是一种代码注入技术，用于攻击数据驱动的应用，恶意的SQL语句被插入到执行的实体字段中（例如，为了转储数据库内容给攻击者） SQL注入，大家都不陌生，是一种常见的攻击方式。攻击者在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），有可能入侵参数检验不足的应用程序。所以，在我们的应用中需要做一些工作，来防备这样的攻击方式。在一些安全性要求很高的应用中（比如银行软件），经常使用将SQL语句全部替换为存储过程这样的方式，来防止SQL注入。这当然是一种很安全的方式，但我们平时开发中，可能不需要这种死板的方式。 3、mybatis是如何做到防止sql注入的MyBatis框架作为一款半自动化的持久层框架，其SQL语句都要我们自己手动编写，这个时候当然需要防止SQL注入。其实，MyBatis的SQL是一个具有“输入+输出”的功能，类似于函数的结构，参考上面的两个例子。其中，parameterType表示了输入的参数类型，resultType表示了输出的参数类型。回应上文，如果我们想防止SQL注入，理所当然地要在输入参数上下功夫。上面代码中使用#的即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的： 1select id, username, password, role from user where username=? and password=? 不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。 【底层实现原理】MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。 1234567//安全的，预编译了的Connection conn = getConn();//获得连接String sql = \"select id, username, password, role from user where id=?\"; //执行sql前会预编译号该条语句PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, id); ResultSet rs=pstmt.executeUpdate(); ...... 【 结论：】 简单说，#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。 如果我们order by语句后用了${}，那么不做任何处理的时候是存在SQL注入危险的。你说怎么防止，那我只能悲惨的告诉你，你得手动处理过滤一下输入的内容。如判断一下输入的参数的长度是否正常（注入语句一般很长），更精确的过滤则可以查询一下输入的参数是否在预期的参数集合中。 4、参考文章http://blog.csdn.net/yizhenn/article/details/52384601 https://www.cnblogs.com/200911/p/5869097.html http://www.jb51.net/article/95314.htm 转自：https://www.cnblogs.com/mmzs/p/8398405.html","categories":[{"name":"数据库","slug":"数据库","permalink":"http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库","slug":"数据库/数据库","permalink":"http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://nimisora.com/tags/Mybatis/"}]},{"title":"预防sql注入","slug":"数据库/预防sql注入","date":"2020-03-01T14:06:50.000Z","updated":"2020-03-13T08:47:01.380Z","comments":true,"path":"post/3NNY5DP.html","link":"","permalink":"http://nimisora.com/post/3NNY5DP.html","excerpt":"","text":"https://www.cnblogs.com/howitworks/archive/2011/07/25/2116471.html 说明 ： 以下内容以mysql为例，其他RDBMS原理一样，但数据库原生函数及SQL语法可能有差异。 一 注入原理我们以登录为例,用户登录时后台会执行SQL语句如下： 1select * from auth_user where user_name = '$&#123;paramter1&#125;' and password = '$&#123;paramter2&#125;' 这时如果我们前台传入到后台的参数是以下情况时： 1$&#123;paramter1&#125;=admin $&#123;paramter2&#125;=' or true or ' 那么后台就会执行 1select * from auth_user where user_name='admin' password =' ' or true or ' ' ; 原本不能查出记录(通过验证)的情况下，通过SQL的注入达到了黑客的目的。 以上为SQL注入原理，通过SQL注入可以达到，DB的安装目录、DB管理员密码查看等等目的，所以我们在写代码时要养成良好习惯。接下来我们来讲解SQL注入的防范及原理。 一 防范原理12345678910111213String stmtSQL = \"select * from auth_user where user_name = ? and password = ?\"; getJdbcTemplate().execute(stmtSQL,new PreparedStatementCallback()&#123; public Object doInPreparedStatement(PreparedStatement ps) throws SQLException &#123; //$&#123;paramter1&#125; ps.setString(1, \"admin\"); //$&#123;paramter2&#125; ps.setString(2, \" ' ' or true or ' ' \"); ps.execute(); //test code return null; &#125; &#125;); 承上SQL注入例子，如果我们对${paramter} 进行相关的验证就可以达到预防的作用。 以java为例: 12345678910111213String stmtSQL = \"select * from auth_user where user_name = ? and password = ?\"; getJdbcTemplate().execute(stmtSQL,new PreparedStatementCallback()&#123; public Object doInPreparedStatement(PreparedStatement ps) throws SQLException &#123; //$&#123;paramter1&#125; ps.setString(1, \"admin\"); //$&#123;paramter2&#125; ps.setString(2, \" ' ' or true or ' ' \"); ps.execute(); //test code return null; &#125; &#125;); 这段程序的原理是将SQL语句进行参数话 1\"insert into auth_user(username,password) values(?,?)\" 将其中的”?”进行参数替换 12345//$&#123;paramter1&#125; ps.setString(1, \"admin\"); //$&#123;paramter2&#125; ps.setString(2, \" ' ' or true or ' ' \"); ps.execute(); 替换的过程一定要注意将特殊的符号进行转义，如: 12' = \\\\'\" =\\\\\" 如上程序，最终执行的SQL为 1select * from auth_user where password =' \\\\' or true or \\\\' ' ; 结果与我们预期一样。 一总结SQL的注入是数据库的基本知识点，所以防范方法已有很多，但是原理其实很简单： 1 参数化SQL语句 2 参数检查，特殊字符进行处理（转义）","categories":[{"name":"sql","slug":"sql","permalink":"http://nimisora.com/categories/sql/"},{"name":"数据库","slug":"sql/数据库","permalink":"http://nimisora.com/categories/sql/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://nimisora.com/tags/sql/"}]},{"title":"Git上线流程","slug":"项目/Git上线流程","date":"2020-03-01T11:50:17.000Z","updated":"2020-03-13T08:41:46.015Z","comments":true,"path":"post/2SRJCNF.html","link":"","permalink":"http://nimisora.com/post/2SRJCNF.html","excerpt":"","text":"","categories":[{"name":"Git","slug":"Git","permalink":"http://nimisora.com/categories/Git/"},{"name":"项目","slug":"Git/项目","permalink":"http://nimisora.com/categories/Git/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://nimisora.com/tags/Git/"}]},{"title":"单点登录","slug":"项目/单点登录","date":"2020-03-01T09:26:09.000Z","updated":"2020-03-13T08:41:16.305Z","comments":true,"path":"post/2MV7VZ1.html","link":"","permalink":"http://nimisora.com/post/2MV7VZ1.html","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"},{"name":"项目","slug":"Java/项目","permalink":"http://nimisora.com/categories/Java/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"单点登录","slug":"单点登录","permalink":"http://nimisora.com/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"}]},{"title":"如何使用两个线程交替打印1--100","slug":"Java/如何使用两个线程交替打印1-100","date":"2020-02-29T09:46:07.000Z","updated":"2020-03-13T08:41:19.549Z","comments":true,"path":"post/1CTB0BQ.html","link":"","permalink":"http://nimisora.com/post/1CTB0BQ.html","excerpt":"","text":"方法1 wait():令当前线程放弃了cpu的资源，使别的线程可以访问共享的资源，而当前的线程排队等待，再次对资源的访问 notify():唤醒正在排队的等待的同步资源的线程， notifyAll()：唤醒正在排队等待的所有的线程 在 java.lang.Object:用这三个方法的注意点： 同步方法或者同步代码块里 使用两个线程打印1—-100.线程1和线程2交替打印 分析： 1.我先使用两个线程打印1—100，（先不用交替打印） 2.然后在使用上面的三个方法，在代码里添加 12345678910111213141516171819202122232425262728293031323334353637383940 class PrintNum implements Runnable &#123; int num = 1; @Override public void run() &#123; // TODO Auto-generated method stub synchronized (this) &#123; while (true) &#123; notify();//唤醒wait()的一个或者所有线程 if (num &lt;= 100) &#123; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":\" + num); num++; &#125; else &#123; break; &#125; try &#123; wait();//释放当前的锁，另一个线程就会进来 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 验证123456789101112131415public class Test4 &#123; public static void main(String[] args) &#123; PrintNum p=new PrintNum(); Thread t1=new Thread(p); Thread t2=new Thread(p); t1.setName(\"甲\"); t2.setName(\"乙\"); t1.start(); t2.start(); &#125; &#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Java","slug":"多线程/Java","permalink":"http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java/"}],"tags":[]},{"title":"Java的生产者-消费者模型","slug":"Java/Java的生产者-消费者模型","date":"2020-02-29T07:54:48.000Z","updated":"2020-03-13T08:41:33.229Z","comments":true,"path":"post/1KJC1GF.html","link":"","permalink":"http://nimisora.com/post/1KJC1GF.html","excerpt":"","text":"","categories":[{"name":"多线程","slug":"多线程","permalink":"http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Java","slug":"多线程/Java","permalink":"http://nimisora.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java/"}],"tags":[{"name":"生产者","slug":"生产者","permalink":"http://nimisora.com/tags/%E7%94%9F%E4%BA%A7%E8%80%85/"},{"name":"消费者","slug":"消费者","permalink":"http://nimisora.com/tags/%E6%B6%88%E8%B4%B9%E8%80%85/"}]},{"title":"Java单例模式","slug":"Java/Java单例模式","date":"2020-02-29T07:54:48.000Z","updated":"2020-03-13T08:41:36.514Z","comments":true,"path":"post/23CXE7H.html","link":"","permalink":"http://nimisora.com/post/23CXE7H.html","excerpt":"","text":"Java单例模式本文首先概述了单例模式产生动机，揭示了单例模式的本质和应用场景。紧接着，我们给出了单例模式在单线程环境下的两种经典实现：饿汉式 和懒汉式，但是饿汉式是线程安全的，而懒汉式是非线程安全的。在多线程环境下，我们特别介绍了五种方式来在多线程环境下创建线程安全的单例，即分别使用synchronized方法、synchronized块、静态内部类、双重检查模式 和ThreadLocal 来实现懒汉式单例，并总结出实现效率高且线程安全的懒汉式单例所需要注意的事项。 一. 单例模式概述单例模式（Singleton），也叫单子模式，是一种常用的设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候，整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，显然，这种方式简化了在复杂环境下的配置管理。 特别地，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。事实上，这些应用都或多或少具有资源管理器的功能。例如，每台计算机可以有若干个打印机，但只能有一个 Printer Spooler(单例) ，以避免两个打印作业同时输出到打印机中。再比如，每台计算机可以有若干通信端口，系统应当集中 (单例)管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。 综上所述，单例模式就是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种方法。 二. 单例模式及其单线程环境下的经典实现单例模式应该是23种设计模式中最简单的一种模式了，下面我们从单例模式的定义、类型、结构和使用要素四个方面来介绍它。 1、单例模式理论基础 定义： 确保一个类只有一个实例，并为整个系统提供一个全局访问点 (向整个系统提供这个实例)。 类型： 创建型模式 结构： 特别地，为了更好地理解上面的类图，我们以此为契机，介绍一下类图的几个知识点： 类图分为三部分，依次是类名、属性、方法； 以&lt;&lt;开头和以&gt;&gt;结尾的为注释信息； 修饰符+代表public，-代表private，#代表protected，什么都没有代表包可见； 带下划线的属性或方法代表是静态的。 三要素： 私有的构造方法； 指向自己实例的私有静态引用； 以自己实例为返回值的静态的公有方法。 2、单线程环境下的两种经典实现 在介绍单线程环境中单例模式的两种经典实现之前，我们有必要先解释一下 立即加载 和延迟加载 两个概念。 立即加载 ： 在类加载初始化的时候就主动创建实例； 延迟加载 ： 等到真正使用的时候才去创建实例，不用时不去主动创建。 在单线程环境下，单例模式根据实例化对象时机的不同，有两种经典的实现：一种是 饿汉式单例(立即加载)，一种是 懒汉式单例(延迟加载)。饿汉式单例在单例类被加载时候，就实例化一个对象并交给自己的引用；而懒汉式单例只有在真正使用的时候才会实例化一个对象并交给自己的引用。代码示例分别如下： 饿汉式单例： 1234567891011121314// 饿汉式单例public class Singleton1 &#123;// 指向自己实例的私有静态引用，主动创建private static Singleton1 singleton1 = new Singleton1();// 私有的构造方法private Singleton1()&#123;&#125;// 以自己实例为返回值的静态的公有方法，静态工厂方法public static Singleton1 getSingleton1()&#123;return singleton1;&#125;&#125; 我们知道，类加载的方式是按需加载，且加载一次。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。 懒汉式单例： 1234567891011121314// 饿汉式单例public class Singleton1 &#123;// 指向自己实例的私有静态引用，主动创建private static Singleton1 singleton1 = new Singleton1();// 私有的构造方法private Singleton1()&#123;&#125;// 以自己实例为返回值的静态的公有方法，静态工厂方法public static Singleton1 getSingleton1()&#123;return singleton1;&#125;&#125; 我们从懒汉式单例可以看到，单例实例被延迟加载，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。 总之，从速度和反应时间角度来讲，饿汉式（又称立即加载）要好一些；从资源利用效率上说，懒汉式（又称延迟加载）要好一些。 3、单例模式的优点 我们从单例模式的定义和实现，可以知道单例模式具有以下几个优点： 在内存中只有一个对象，节省内存空间； 避免频繁的创建销毁对象，可以提高性能； 避免对共享资源的多重占用，简化访问； 为整个系统提供一个全局访问点。 4、单例模式的使用场景 由于单例模式具有以上优点，并且形式上比较简单，所以是日常开发中用的比较多的一种设计模式，其核心在于为整个系统提供一个唯一的实例，其应用场景包括但不仅限于以下几种： 有状态的工具类对象； 频繁访问数据库或文件的对象； 5、单例模式的注意事项 在使用单例模式时，我们必须使用单例类提供的公有工厂方法得到单例对象，而不应该使用反射来创建，否则将会实例化一个新对象。此外，在多线程环境下使用单例模式时，应特别注意线程安全问题，我在下文会重点讲到这一点。 三. 多线程环境下单例模式的实现在单线程环境下，无论是饿汉式单例还是懒汉式单例，它们都能够正常工作。但是，在多线程环境下，情形就发生了变化：由于饿汉式单例天生就是线程安全的，可以直接用于多线程而不会出现问题；但懒汉式单例本身是非线程安全的，因此就会出现多个实例的情况，与单例模式的初衷是相背离的。下面我重点阐述以下几个问题： 为什么说饿汉式单例天生就是线程安全的？ 传统的懒汉式单例为什么是非线程安全的？ 怎么修改传统的懒汉式单例，使其线程变得安全？ 线程安全的单例的实现还有哪些，怎么实现？ 双重检查模式、Volatile关键字 在单例模式中的应用 ThreadLocal 在单例模式中的应用 特别地，为了能够更好的观察到单例模式的实现是否是线程安全的，我们提供了一个简单的测试程序来验证。该示例程序的判断原理是： 开启多个线程来分别获取单例，然后打印它们所获取到的单例的hashCode值。若它们获取的单例是相同的(该单例模式的实现是线程安全的)，那么它们的hashCode值一定完全一致；若它们的hashCode值不完全一致，那么获取的单例必定不是同一个，即该单例模式的实现不是线程安全的，是多例的。注意，相应输出结果附在每个单例模式实现示例后。 1234567891011121314// 饿汉式单例public class Singleton1 &#123;// 指向自己实例的私有静态引用，主动创建private static Singleton1 singleton1 = new Singleton1();// 私有的构造方法private Singleton1()&#123;&#125;// 以自己实例为返回值的静态的公有方法，静态工厂方法public static Singleton1 getSingleton1()&#123;return singleton1;&#125;&#125; 1、为什么说饿汉式单例天生就是线程安全的？ 1234567891011121314// 饿汉式单例public class Singleton1 &#123;// 指向自己实例的私有静态引用，主动创建private static Singleton1 singleton1 = new Singleton1();// 私有的构造方法private Singleton1()&#123;&#125;// 以自己实例为返回值的静态的公有方法，静态工厂方法public static Singleton1 getSingleton1()&#123;return singleton1;&#125;&#125; 该实现与上面传统懒汉式单例的实现唯一的差别就在于：是否使用 synchronized 修饰 getSingleton2()方法。若使用，就保证了对临界资源的同步互斥访问，也就保证了单例。 从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低，因为同步块的作用域有点大，而且锁的粒度有点粗。同步方法效率低，那我们考虑使用同步代码块来实现。 2)、同步延迟加载 — synchronized块 1234567891011121314// 饿汉式单例public class Singleton1 &#123;// 指向自己实例的私有静态引用，主动创建private static Singleton1 singleton1 = new Singleton1();// 私有的构造方法private Singleton1()&#123;&#125;// 以自己实例为返回值的静态的公有方法，静态工厂方法public static Singleton1 getSingleton1()&#123;return singleton1;&#125;&#125; 该实现与上面synchronized方法版本实现类似，此不赘述。从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率仍然比较低，事实上，和使用synchronized方法的版本相比，基本没有任何效率上的提高。 3)、同步延迟加载 — 使用内部类实现延迟加载 12345678910111213141516171819202122232425262728// 线程安全的懒汉式单例public class Singleton5 &#123;// 私有内部类，按需加载，用时加载，也就是延迟加载private static class Holder &#123;private static Singleton5 singleton5 = new Singleton5();&#125;private Singleton5() &#123;&#125;public static Singleton5 getSingleton5() &#123;return Holder.singleton5;&#125;&#125;/* Output(完全一致):482535999482535999482535999482535999482535999482535999482535999482535999482535999482535999*///:~ 如上述代码所示，我们可以使用内部类实现线程安全的懒汉式单例，这种方式也是一种效率比较高的做法。至于其为什么是线程安全的，其与问题 “为什么说饿汉式单例天生就是线程安全的？” 相类似，此不赘述。 四. 单例模式与双重检查(Double-Check idiom)使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，其不但保证了单例，而且切实提高了程序运行效率。对应的代码清单如下： 12345678910111213141516171819202122232425262728293031323334// 线程安全的懒汉式单例public class Singleton3 &#123; //使用volatile关键字防止重排序，因为 new Instance()是一个非原子操作， //可能创建一个不完整的实例 private static volatile Singleton3 singleton3; private Singleton3() &#123; &#125; public static Singleton3 getSingleton3() &#123; // Double-Check idiom if (singleton3 == null) &#123; synchronized (Singleton3.class) &#123; // 1 // 只需在第一次创建实例时才同步 if (singleton3 == null) &#123; // 2 singleton3 = new Singleton3(); // 3 &#125; &#125; &#125; return singleton3; &#125; /* Output(完全一致): 1104499981 1104499981 1104499981 1104499981 1104499981 1104499981 1104499981 1104499981 1104499981 1104499981 *///:~ 如上述代码所示，为了在保证单例的前提下提高运行效率，我们需要对 singleton3 进行第二次检查，目的是避开过多的同步（因为这里的同步只需在第一次创建实例时才同步，一旦创建成功，以后获取实例时就不需要同步获取锁了）。这种做法无疑是优秀的，但是我们必须注意一点： 必须使用volatile关键字修饰单例引用。 那么，如果上述的实现没有使用 volatile 修饰 singleton3，会导致什么情形发生呢？ 为解释该问题，我们分两步来阐述： (1)、当我们写了 new 操作，JVM 到底会发生什么？ 首先，我们要明白的是： new Singleton3() 是一个非原子操作。代码行singleton3 = new Singleton3(); 的执行过程可以形象地用如下3行伪代码来表示： memory = allocate(); //1:分配对象的内存空间 ctorInstance(memory); //2:初始化对象 singleton3 = memory; //3:使singleton3指向刚分配的内存地址但实际上，这个过程可能发生无序写入(指令重排序)，也就是说上面的3行指令可能会被重排序导致先执行第3行后执行第2行，也就是说其真实执行顺序可能是下面这种： memory = allocate(); //1:分配对象的内存空间 singleton3 = memory; //3:使singleton3指向刚分配的内存地址 ctorInstance(memory); //2:初始化对象这段伪代码演示的情况不仅是可能的，而且是一些 JIT 编译器上真实发生的现象。 (2)、重排序情景再现 了解 new 操作是非原子的并且可能发生重排序这一事实后，我们回过头看使用 Double-Check idiom 的同步延迟加载的实现： 我们需要重新考察上述清单中的 //3 行。此行代码创建了一个 Singleton 对象并初始化变量 singleton3 来引用此对象。这行代码存在的问题是，在 Singleton 构造函数体执行之前，变量 singleton3 可能提前成为非 null 的，即赋值语句在对象实例化之前调用，此时别的线程将得到的是一个不完整（未初始化）的对象，会导致系统崩溃。下面是程序可能的一组执行步骤： 1、线程 1 进入 getSingleton3() 方法； 2、由于 singleton3 为 null，线程 1 在 //1 处进入 synchronized 块； 3、同样由于 singleton3 为 null，线程 1 直接前进到 //3 处，但在构造函数执行之前，使实例成为非 null，并且该实例是未初始化的； 4、线程 1 被线程 2 预占； 5、线程 2 检查实例是否为 null。因为实例不为 null，线程 2 得到一个不完整（未初始化）的 Singleton 对象； 6、线程 2 被线程 1 预占。 7、线程 1 通过运行 Singleton3 对象的构造函数来完成对该对象的初始化。 显然，一旦我们的程序在执行过程中发生了上述情形，就会造成灾难性的后果，而这种安全隐患正是由于指令重排序的问题所导致的。让人兴奋地是，volatile 关键字正好可以完美解决了这个问题。也就是说，我们只需使用volatile关键字修饰单例引用就可以避免上述灾难。 五. 单例模式 与 ThreadLocal借助于 ThreadLocal，我们可以实现双重检查模式的变体。我们将临界资源线程局部化，具体到本例就是将双重检测的第一层检测条件 if (instance == null) 转换为 线程局部范围内的操作 。这里的 ThreadLocal 也只是用作标识而已，用来标识每个线程是否已访问过：如果访问过，则不再需要走同步块，这样就提高了一定的效率。对应的代码清单如下： 123456789101112131415161718192021222324252627282930313233343536// 线程安全的懒汉式单例 public class Singleton4 &#123; // ThreadLocal 线程局部变量 private static ThreadLocal&lt;Singleton4&gt; threadLocal = new ThreadLocal&lt;Singleton4&gt;(); // 不需要是 private Singleton4()&#123;&#125; public static Singleton4 getSingleton4()&#123; // 第一次检查：该线程是否第一次访问 createSingleton4(); &#125; return singleton4; &#125; public static void createSingleton4()&#123; synchronized (Singleton4.class) &#123; // 第二次检查：该单例是否被创建 // 只执行一次 &#125; &#125; // 将单例放入当前线程的局部变量中 &#125; /* Output(完全一致): 1028355155 1028355155 1028355155 1028355155 1028355155 1028355155 1028355155 1028355155 1028355155 1028355155 *///:~ 借助于 ThreadLocal，我们也可以实现线程安全的懒汉式单例。但与直接双重检查模式使用，使用ThreadLocal的实现在效率上还不如双重检查锁定。 六. 小结本文首先介绍了单例模式的定义和结构，并给出了其在单线程和多线程环境下的几种经典实现。特别地，我们知道，传统的饿汉式单例无论在单线程还是多线程环境下都是线程安全的，但是传统的懒汉式单例在多线程环境下是非线程安全的。为此，我们特别介绍了五种方式来在多线程环境下创建线程安全的单例，包括： 使用synchronized方法实现懒汉式单例； 使用synchronized块实现懒汉式单例； 使用静态内部类实现懒汉式单例； 使用双重检查模式实现懒汉式单例； 使用ThreadLocal实现懒汉式单例； 当然，实现懒汉式单例还有其他方式。但是，这五种是比较经典的实现，也是我们应该掌握的几种实现方式。从这五种实现中，我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点： 尽量减少同步块的作用域； 尽量使用细粒度的锁。 本文转自：书呆子Rico 的博客http://blog.csdn.net/justloveyou_/article/details/64127789","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"设计模式/Java","permalink":"http://nimisora.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java/"}],"tags":[{"name":"饱汉","slug":"饱汉","permalink":"http://nimisora.com/tags/%E9%A5%B1%E6%B1%89/"},{"name":"懒汉","slug":"懒汉","permalink":"http://nimisora.com/tags/%E6%87%92%E6%B1%89/"}]},{"title":"头条面试1","slug":"头条面试1","date":"2020-02-29T04:26:09.000Z","updated":"2020-02-29T04:32:24.325Z","comments":true,"path":"post/3Q8345K.html","link":"","permalink":"http://nimisora.com/post/3Q8345K.html","excerpt":"","text":"1.题目描述给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。举例：nums = {-1,1,1,1},那么你应该返回的是：1。因为这个数组所有数的平方取值都是1，只有一种取值nums = {-1,0,1,2,3}你应该返回4，因为nums数组所有元素的平方值一共4种取值：1,0,4,9 2.解题思路使用双指针，从两边向中间扫描。将绝对值大的数字删掉，计数即可，并记录刚才删除的数值的绝对值，以免出现多次相同的数据，重复计数的问题。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int squareUniqueNum(vector&lt;int&gt; &amp;ver) &#123; int len = ver.size(); if (len &lt; 2) return len; int i = 0; int j = len - 1; int pre = abs(ver[0]); ///记录上次删除数据的绝对值 int num = 1; ///数字为 1 while (i &lt;= j) &#123; ///每次删除绝对值较大的数字，并记录下删除是数字的绝对值，绝对值相同的只计数一次 if (abs(ver[i]) &gt; abs(ver[j])) &#123; if (pre != abs(ver[i])) &#123; ///如果没有删过 num++; pre = abs(ver[i]); &#125; i++; &#125; else &#123; if (pre != abs(ver[j])) &#123; ///如果没有删过 num++; pre = abs(ver[j]); &#125; j--; &#125; &#125; return num;&#125;int main() &#123; vector&lt;int&gt; ver(&#123;-5, -3, -1, 1, 1, 2&#125;); int num = squareUniqueNum(ver); ///求有序数组中数字平方后，消重结果中数字的个数 cout &lt;&lt; num &lt;&lt; endl; return 0;&#125;","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://nimisora.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"头条","slug":"头条","permalink":"http://nimisora.com/tags/%E5%A4%B4%E6%9D%A1/"}]},{"title":"HashMap和HashTable的区别","slug":"Java/HashTable和HashMap的区别","date":"2020-02-29T04:26:09.000Z","updated":"2020-03-13T08:42:11.479Z","comments":true,"path":"post/27K0F09.html","link":"","permalink":"http://nimisora.com/post/27K0F09.html","excerpt":"","text":"线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）； 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它； 对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。 初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 HashMap 中带有初始容量的构造函数： 123456789101112131415public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; 下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。 123456789101112/** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"},{"name":"Java","slug":"Java/Java","permalink":"http://nimisora.com/categories/Java/Java/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://nimisora.com/tags/HashMap/"},{"name":"HashTable","slug":"HashTable","permalink":"http://nimisora.com/tags/HashTable/"}]},{"title":"SpringBean","slug":"Java/SpringBean","date":"2020-02-29T00:54:48.000Z","updated":"2020-03-13T08:44:31.030Z","comments":true,"path":"post/N0GW0.html","link":"","permalink":"http://nimisora.com/post/N0GW0.html","excerpt":"","text":"1、spring如何管理bean、bean的生命周期2、spring管理的bean有哪些模式，spring默认的是什么模式 1234&lt;beans&gt; &lt;bean id=\"demoBean\" class=\"com.somnus.task.DemoBean\" init-method=\"customInit\" destroy-method=\"customDestroy\"&gt;&lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"},{"name":"Java","slug":"Java/Java","permalink":"http://nimisora.com/categories/Java/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://nimisora.com/tags/Spring/"},{"name":"Bean","slug":"Bean","permalink":"http://nimisora.com/tags/Bean/"}]},{"title":"InnoDB的区别","slug":"数据库/MyISAM和InnoDB的区别","date":"2020-02-29T00:54:48.000Z","updated":"2020-03-13T08:43:27.841Z","comments":true,"path":"post/2ZQH97N.html","link":"","permalink":"http://nimisora.com/post/2ZQH97N.html","excerpt":"","text":"MyISAM与InnoDB 的区别（9个不同点）区别： InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。 MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）； 那么为什么InnoDB没有了这个变量呢？ 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。 如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS 5、Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了 6、MyISAM表格可以被压缩后进行查询操作 7、InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁 InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。 例如： t_user(uid, uname, age, sex) innodb; uid PK 无其他索引 update t_user set age=10 where uid=1; 命中索引，行锁。 update t_user set age=10 where uid != 1; 未命中索引，表锁。 update t_user set age=10 where name=&apos;chackca&apos;; 无索引，表锁。8、InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有 9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI Innodb：frm是表定义文件，ibd是数据文件 Myisam：frm是表定义文件，myd是数据文件，myi是索引文件 如何选择： 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM； 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。 系统奔溃后，MyISAM恢复起来更困难，能否接受； MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。 InnoDB为什么推荐使用自增ID作为主键？ 答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。 innodb引擎的4大特性 插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库","slug":"数据库/数据库","permalink":"http://nimisora.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MyISAM","slug":"MyISAM","permalink":"http://nimisora.com/tags/MyISAM/"}]},{"title":"七层模型以及五层协议","slug":"计算机网络/七层模型以及五层协议","date":"2020-02-28T14:35:43.000Z","updated":"2020-03-13T01:04:19.563Z","comments":true,"path":"post/R562ZK.html","link":"","permalink":"http://nimisora.com/post/R562ZK.html","excerpt":"","text":"tcp/ip 四层模型和 osi 七层模型以及五层协议 应用层：直接为用户的应用进程提供服务，如 HTTP、支持文件传输的 FTP 协议等;该层直接面向用户，是OSI中的最高层。它的主要任务是为用户提供应用的接口，即提供不同计算机间的文件传送、访问与管理，电子邮件的内容处理，不同计算机通过网络交互访问的虚拟终端功能等。 表示层该层的主要任务是把所传送的数据的抽象语法变换为传送语法，即把不同计算机内部的不同表示形式转换成网络通信中的标准表示形式。此外，对传送的数据加密（或解密）、正文压缩（或还原）也是表示层的任务。 会话层该层对传输的报文提供同步管理服务。在两个不同系统的互相通信的应用进程之间建立、组织和协调交互。例如，确定是双工还是半双工工作。 运输层：向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务。分用则是运输层把收到的信息分别交付给上面应用层中的相应的进程。运输层主要使用以下两种协议：1.传输控制协议TCP（数据传输的单位是报文段）2.用户数据报协议UDP（数据传输的单位是用户数据报），不保证提供可靠的交付，只能提供“尽最大努力交付” 网络层：使用无连接的网际协议 IP 和许多种路由选择协议。负责为分组交换网上的不同主机提供通信服务，把运输层产生的报文段或用户数据报封装成分组（也叫IP数据报或数据报）或包进行传送。网络层的另一个任务就是选择合适的路由。 数据链路层（链路层）：将网络层交下来的 IP 数据报组装成帧，在两个相邻结点（主机和路由器，或两个路由器）之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。 （透明表示无论什么样的比特组合的数据都能够通过这个数据链路层） 如发现有差错，会简单的丢弃帧。如果需要改正错误，由运输层的 TCP 来完成。 物理层：传送数据的单位是比特。物理层的任务就是透明地传送比特流。 要考虑用多大的电压代表“1” 或 ”0”，以及接受方如何识别出发送方所发的比特。还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。 当然，哪几个比特代表什么意思，则不是物理层所要管的。 请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。因此也有人把物理媒体层当作第0层。 第2层（数据链路层）数据单元 PDU 的首尾都要加上控制信息。 物理层不需要加控制信息，但要注意传送比特流时应从首部开始传送。 －－－－－－－－－－－－－－－－－－－－－－TCP/IP 四层协议－－－－－－－－－－－－－－－－－－－－－－－－－－－ TCP/IP 协议可以为各式各样的应用提供服务（所谓的 everything over IP），同时 TCP/IP 协议也允许 IP 协议在各式各样的网络构成的互联网上运行（所谓的 IP over everything） 数据链路层包括了硬件接口和协议ARP，RARP，这两个协议主要是用来建立送到物理层上的信息和接收从物理层上传来的信息； 网络层中的协议主要有IP，ICMP，IGMP等，由于它包含了IP协议模块，所以它是所有机遇TCP/IP协议网络的核心。在网络层中，IP模块完成大部分功能。ICMP和IGMP以及其他支持IP的协议帮助IP完成特定的任务，如传输差错控制信息以及主机/路由器之间的控制电文等。网络层掌管着网络中主机间的信息传输。 传输层上的主要协议是TCP和UDP。正如网络层控制着主机之间的数据传递，传输层控制着那些将要进入网络层的数据。两个协议就是它管理这些数据的两种方式：TCP是一个基于连接的协议（还记得我们在网络基础中讲到的关于面向连接的服务和面向无连接服务的概念吗？忘了的话，去看看）；UDP则是面向无连接服务的管理方式的协议。 应用层位于协议栈的顶端，它的主要任务就是应用了。上面的协议当然也是为了这些应用而设计的，具体说来一些常用的协议功能如下： Telnet：提供远程登录（终端仿真）服务，好象比较古老的BBS就是用的这个登陆。 FTP ：提供应用级的文件传输服务，说的简单明了点就是远程文件访问等等服务； SMTP：不用说拉，天天用到的电子邮件协议。 TFTP：提供小而简单的文件传输服务，实际上从某个角度上来说是对FTP的一种替换（在文件特别小并且仅有传输需求的时候）。 SNTP：简单网络管理协议。看名字就不用说什么含义了吧。 DNS：域名解析服务，也就是如何将域名映射城IP地址的协议。 HTTP：不知道各位对这个协议熟不熟悉啊？这是超文本传输协议，你之所以现在能看到网上的图片，动画，音频，等等，都是仰仗这个协议在起作用啊！","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://nimisora.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机网络","slug":"计算机网络/计算机网络","permalink":"http://nimisora.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://nimisora.com/tags/HTTP/"},{"name":"TCP","slug":"TCP","permalink":"http://nimisora.com/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"http://nimisora.com/tags/UDP/"},{"name":"IP","slug":"IP","permalink":"http://nimisora.com/tags/IP/"}]},{"title":"ThreadPoolExecutor线程池的使用","slug":"Java/ThreadPoolExecutor线程池的使用","date":"2020-02-27T09:26:57.000Z","updated":"2020-03-13T08:44:03.484Z","comments":true,"path":"post/5AFM83.html","link":"","permalink":"http://nimisora.com/post/5AFM83.html","excerpt":"","text":"最近看阿里的 Java开发手册，上面有线程池的一个建议： 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 结合最近面试的经历，发现这条建议还是十分有用的，因为自己经常使用Executors提供的工厂方法创建线程池，所以忽略了线程池内部的实现。特别是拒绝策略，面试被问到两次，因为使用Executors创建线程池不会传入这个参数而使用默认值所以我们常常忽略这一参数，还好因为这条建议，自己提前熟悉了一下ThreadPoolExecutor。 ThreadPoolExecutor先看看如何使用ThreadPoolExecutor创建线程池： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize - 线程池核心池的大小。maximumPoolSize - 线程池的最大线程数。keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。unit - keepAliveTime 的时间单位。workQueue - 用来储存等待执行任务的队列。threadFactory - 线程工厂。handler - 拒绝策略。 关注点1 线程池大小线程池有两个线程数的设置，一个为核心池线程数，一个为最大线程数。在创建了线程池后，默认情况下，线程池中并没有任何线程，等到有任务来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法当创建的线程数等于 corePoolSize 时，会加入设置的阻塞队列。当队列满时，会创建线程执行任务直到线程池中的数量等于maximumPoolSize。 关注点2 适当的阻塞队列java.lang.IllegalStateException: Queue full方法 抛出异常 返回特殊值 一直阻塞 超时退出插入方法 add(e) offer(e) put(e) offer(e,time,unit)移除方法 remove() poll() take() poll(time,unit)检查方法 element() peek() 不可用 不可用 ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。DelayQueue： 一个使用优先级队列实现的无界阻塞队列。SynchronousQueue： 一个不存储元素的阻塞队列。LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列。LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。 关注点3 明确拒绝策略ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。 (默认)ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 说明：Executors 各个方法的弊端：1）newFixedThreadPool 和 newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。2）newCachedThreadPool 和 newScheduledThreadPool:主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。 Executors让我们再看看Executors提供的那几个工厂方法。 newSingleThreadExecutor创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 1new ThreadPoolExecutor(1, 1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()) newFixedThreadPool创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 1new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); newCachedThreadPool创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 1new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());","categories":[{"name":"线程池","slug":"线程池","permalink":"http://nimisora.com/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"Java","slug":"线程池/Java","permalink":"http://nimisora.com/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/Java/"}],"tags":[{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://nimisora.com/tags/ThreadPoolExecutor/"}]},{"title":"HashMap为何多线程下不安全","slug":"Java/HashMap为何多线程下不安全","date":"2020-02-26T15:53:04.000Z","updated":"2020-03-13T08:42:08.400Z","comments":true,"path":"post/139TWV2.html","link":"","permalink":"http://nimisora.com/post/139TWV2.html","excerpt":"","text":"HashMap线程不安全的体现 - developer_chan - 博客园https://www.cnblogs.com/developer_chan/p/10450908.html 前言：我们都知道HashMap是线程不安全的，在多线程环境中不建议使用，但是其线程不安全主要体现在什么地方呢，本文将对该问题进行解密。 1.jdk1.7中的HashMap在jdk1.8中对HashMap做了很多优化，这里先分析在jdk1.7中的问题，相信大家都知道在jdk1.7多线程环境下HashMap容易出现死循环，这里我们先用代码来模拟出现死循环的情况： 12345678910111213141516171819202122232425262728 1 public class HashMapTest &#123; 2 3 public static void main(String[] args) &#123; 4 HashMapThread thread0 = new HashMapThread(); 5 HashMapThread thread1 = new HashMapThread(); 6 HashMapThread thread2 = new HashMapThread(); 7 HashMapThread thread3 = new HashMapThread(); 8 HashMapThread thread4 = new HashMapThread(); 9 thread0.start();10 thread1.start();11 thread2.start();12 thread3.start();13 thread4.start();14 &#125;15 &#125;16 17 class HashMapThread extends Thread &#123;18 private static AtomicInteger ai = new AtomicInteger();19 private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();20 21 @Override22 public void run() &#123;23 while (ai.get() &lt; 1000000) &#123;24 map.put(ai.get(), ai.get());25 ai.incrementAndGet();26 &#125;27 &#125;28 &#125;上述代码比较简单，就是开多个线程不断进行put操作，并且HashMap与AtomicInteger都是全局共享的。在多运行几次该代码后，出现如下死循环情形： 其中有几次还会出现数组越界的情况： 这里我们着重分析为什么会出现死循环的情况，通过jps和jstack命名查看死循环情况，结果如下： 从堆栈信息中可以看到出现死循环的位置，通过该信息可明确知道死循环发生在HashMap的扩容函数中，根源在transfer函数中，jdk1.7中HashMap的transfer函数如下： 123456789101112131415 1 void transfer(Entry[] newTable, boolean rehash) &#123; 2 int newCapacity = newTable.length; 3 for (Entry&lt;K,V&gt; e : table) &#123; 4 while(null != e) &#123; 5 Entry&lt;K,V&gt; next = e.next; 6 if (rehash) &#123; 7 e.hash = null == e.key ? 0 : hash(e.key); 8 &#125; 9 int i = indexFor(e.hash, newCapacity);10 e.next = newTable[i];11 newTable[i] = e;12 e = next;13 &#125;14 &#125;15 &#125;总结下该函数的主要作用： 在对table进行扩容到newTable后，需要将原来数据转移到newTable中，注意10-12行代码，这里可以看出在转移元素的过程中，使用的是头插法，也就是链表的顺序会翻转，这里也是形成死循环的关键点。下面进行详细分析。 1.1 扩容造成死循环分析过程前提条件： 这里假设 #1.hash算法为简单的用key mod链表的大小。 #2.最开始hash表size=2，key=3,7,5，则都在table[1]中。 #3.然后进行resize，使size变成4。 未resize前的数据结构如下： 如果在单线程环境下，最后的结果如下： 这里的转移过程，不再进行详述，只要理解transfer函数在做什么，其转移过程以及如何对链表进行反转应该不难。 然后在多线程环境下，假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中第11行代码处挂起，因为该函数在这里分析的地位非常重要，因此再次贴出来。 此时线程A中运行结果如下： 线程A挂起后，此时线程B正常执行，并完成resize操作，结果如下： 这里需要特别注意的点：由于线程B已经执行完毕，根据Java内存模型，现在newTable和table中的Entry都是主存中最新值：7.next=3，3.next=null。 此时切换到线程A上，在线程A挂起时内存中值如下：e=3，next=7，newTable[3]=null，代码执行过程如下： newTable[3]=e ----&gt; newTable[3]=3 e=next ----&gt; e=7此时结果如下： 继续循环： 从主存中取值】从主存中取值】 再次进行循环： e.next=7 即：3.next=7e=null注意此次循环：e.next=7，而在上次循环中7.next=3，出现环形链表，并且此时e=null循环结束。 在后续操作中只要涉及轮询hashmap的数据结构，就会在这里发生死循环，造成悲剧。 1.2 扩容造成数据丢失分析过程遵照上述分析过程，初始时： 线程A和线程B进行put操作，同样线程A挂起： 此时线程A的运行结果如下： 此时线程B已获得CPU时间片，并完成resize操作： 同样注意由于线程B执行完成，newTable和table都为最新值：5.next=null。 此时切换到线程A，在线程A挂起时：e=7，next=5，newTable[3]=null。 执行newtable[i]=e，就将7放在了table[3]的位置，此时next=5。接着进行下一次循环： 从主存中取值从主存中取值e=null将5放置在table[1]位置，此时e=null循环结束，3元素丢失，并形成环形链表。并在后续操作hashmap时造成死循环。 2.jdk1.8中HashMap在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全，这里我们看jdk1.8中HashMap的put操作源码： 123456789101112131415161718192021222324252627282930313233343536373839404142 1 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, 2 boolean evict) &#123; 3 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 4 if ((tab = table) == null || (n = tab.length) == 0) 5 n = (tab = resize()).length; 6 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果没有hash碰撞则直接插入元素 7 tab[i] = newNode(hash, key, value, null); 8 else &#123; 9 Node&lt;K,V&gt; e; K k;10 if (p.hash == hash &amp;&amp;11 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))12 e = p;13 else if (p instanceof TreeNode)14 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);15 else &#123;16 for (int binCount = 0; ; ++binCount) &#123;17 if ((e = p.next) == null) &#123;18 p.next = newNode(hash, key, value, null);19 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st20 treeifyBin(tab, hash);21 break;22 &#125;23 if (e.hash == hash &amp;&amp;24 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))25 break;26 p = e;27 &#125;28 &#125;29 if (e != null) &#123; // existing mapping for key30 V oldValue = e.value;31 if (!onlyIfAbsent || oldValue == null)32 e.value = value;33 afterNodeAccess(e);34 return oldValue;35 &#125;36 &#125;37 ++modCount;38 if (++size &gt; threshold)39 resize();40 afterNodeInsertion(evict);41 return null;42 &#125;这是jdk1.8中HashMap中put操作的主函数， 注意第6行代码，如果没有hash碰撞则会直接插入元素。如果线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入第6行代码中。假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给覆盖，发生线程不安全。 这里只是简要分析下jdk1.8中HashMap出现的线程不安全问题的体现，后续将会对java的集合框架进行总结，到时再进行具体分析。 总结首先HashMap是线程不安全的，其主要体现： #1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。 #2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。 by Shawn Chen，2019.03.02，上午。","categories":[{"name":"Java","slug":"Java","permalink":"http://nimisora.com/categories/Java/"},{"name":"Java","slug":"Java/Java","permalink":"http://nimisora.com/categories/Java/Java/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://nimisora.com/tags/HashMap/"}]},{"title":"Post和Get的区别","slug":"计算机网络/PUT和GET的区别","date":"2020-02-25T02:58:03.000Z","updated":"2020-03-13T08:43:48.861Z","comments":true,"path":"post/3SQTM19.html","link":"","permalink":"http://nimisora.com/post/3SQTM19.html","excerpt":"","text":"转载自：https://www.cnblogs.com/liziweiblog/p/11066333.html POST和GET是什么？POST和GET是HTTP请求的两种方式，都可实现将数据从浏览器向服务器发送带参数的请求。 HTTP请求底层协议都是TCP/IP，所以两者没有本质的区别。 HTTPHTTP是什么HTTP：超文本传输协议。所有的WWW文件都必须遵守这个标准。 HTTP向服务器发送请求是TCP连接。HTTP服务器收到请求后向客户端返回一个状态行 比如“HTTP/1.1 200 OK”和 HTTP请求的组成HTTP由四部分组成： 请求行（request line）：用于说明请求类型、要访问的资源路径、HTTP版本号（GET /index.html HTTP/1.1） 请求头部（header）：用于说明服务器要使用的附加信息 一个空行 请求数据（body）：任意添加的数据 eg: 123456789101112131415161718192021GET /books/?sex=man&amp;name=Professional HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Connection: Keep-Alive这里是空行------------------------------------------------------------------------------POST /index.html HTTP/1.1 请求方法 url 协议/版本号Host: localhost 主机地址User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 发送请求的应用程序名称Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,zh;q=0.5 通知服务端可以发送的语言Accept-Encoding: gzip, deflate 通知服务端可以发送的数据压缩格式Connection: keep-aliveReferer: &lt;a target=_blank href=\"http://localhost/\" style=\"color: rgb(51, 102, 153); text-decoration: none;\"&gt;http://localhost/&lt;/a&gt;Content-Length：25Content-Type：application/x-www-form-urlencoded请求空行 标志着请求头结束，请求正文（请求体）的开始username=aa&amp;password=1234 GET方法GET是获取的意思，顾名思义就是获取信息。 GET是默认的HTTP请求方法。 GET方法把参数通过key/value形式存放在URL里面，如果参数是英文数字原样显示，如果是中文或者其他字符加密（Base64）URL长度一般有限制所以GET方法的参数长度不能太长。由于参数显示再地址栏所以不安全，一般需要保密的请求不使用GET。 POST方法POST是邮件的意思，顾名思义就像一封信一样将参数放在信封里面传输。它用于修改服务器上的数据，一般这些数据是应该保密的，就像信件一样，信的内容只能收信的人看见。例入当用户输入账号和密码登录时账号和密码作为参数通过HTTP请求传输到服务器，这时候肯定不能用GET方法将账号密码直接显示再URL上，这时候就应该用POST方法保证数据的保密性。 POST和GET的区别 GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密） GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源） GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有 GET可以被保存为书签，POST不可以。这一点也能感受到。 GET能被缓存，POST不能 GET只允许ASCII字符，POST没有限制 GET会保存再浏览器历史记录中，POST不会。这点也能感受到。 总之，两者之间没有本质区别，区别就在于数据存储的位置。各自有适用环境，根据需求选择合适的方法即可。 还有哪些HTTP请求方法GET和POST是最常用的HTTP请求方式。还有其他的请求方式。我没用过其他的，我只说我知道的把。以后遇到了再补充。 PUT: HEAD DELETE …","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://nimisora.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机网络","slug":"计算机网络/计算机网络","permalink":"http://nimisora.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://nimisora.com/tags/HTTP/"},{"name":"Post","slug":"Post","permalink":"http://nimisora.com/tags/Post/"},{"name":"Get","slug":"Get","permalink":"http://nimisora.com/tags/Get/"}]},{"title":"146. LRU缓存机制","slug":"Leetcode/146 LRU","date":"2015-10-25T15:36:54.000Z","updated":"2020-03-13T08:41:03.580Z","comments":true,"path":"post/9546P4.html","link":"","permalink":"http://nimisora.com/post/9546P4.html","excerpt":"","text":"Problem: Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) – Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) – Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 Time Complexity: Put O(1) Get O(1) Idea: Use Hashtable for fast mapping and double linked list for fast manipulation. Solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class LRUCache &#123; public: LRUCache(int capacity) &#123; capacity_=capacity; &#125; int get(int key) &#123; const auto it=m_.find(key); //if key does not exist if(it==m_.cend()) return -1; //Move this key to the front of hte list cache_.splice(cache_.begin(),cache_,it-&gt;second); return it-&gt;second-&gt;second; &#125; void put(int key, int value) &#123; const auto it=m_.find(key); //Key already exists if(it!=m_.cend())&#123; //Update the value it-&gt;second-&gt;second=value; //Move this key to the front of the list cache_.splice(cache_.begin(),cache_,it-&gt;second); return; &#125; //key does not exist //Reached the capacity,remove the oldest element if(cache_.size()==capacity_)&#123; const auto&amp; node =cache_.back(); m_.erase(node.first); cache_.pop_back(); &#125; //Insert the entry into list and update mapping. cache_.emplace_front(key,value); m_[key]=cache_.begin(); &#125; private: int capacity_; list&lt;pair&lt;int,int&gt;&gt; cache_; unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; m_; &#125;; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://nimisora.com/categories/Leetcode/"},{"name":"Leetcode","slug":"Leetcode/Leetcode","permalink":"http://nimisora.com/categories/Leetcode/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://nimisora.com/tags/Leetcode/"}]}]}